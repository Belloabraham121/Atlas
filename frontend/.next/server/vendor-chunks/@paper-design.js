"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paper-design";
exports.ids = ["vendor-chunks/@paper-design"];
exports.modules = {

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shader-mount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\");\n/* harmony import */ var _use_merge_refs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./use-merge-refs.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */ /* __next_internal_client_entry_do_not_use__ ShaderMount auto */ \n\n\n\nasync function processUniforms(uniformsProp) {\n    const processedUniforms = {};\n    const imageLoadPromises = [];\n    const isValidUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return true;\n            new URL(url);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    const isExternalUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return false;\n            const urlObject = new URL(url, window.location.origin);\n            return urlObject.origin !== window.location.origin;\n        } catch  {\n            return false;\n        }\n    };\n    Object.entries(uniformsProp).forEach(([key, value])=>{\n        if (typeof value === \"string\") {\n            if (!value) {\n                processedUniforms[key] = (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.getEmptyPixel)();\n                return;\n            }\n            if (!isValidUrl(value)) {\n                console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n                return;\n            }\n            const imagePromise = new Promise((resolve, reject)=>{\n                const img = new Image();\n                if (isExternalUrl(value)) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                img.onload = ()=>{\n                    processedUniforms[key] = img;\n                    resolve();\n                };\n                img.onerror = ()=>{\n                    console.error(`Could not set uniforms. Failed to load image at ${value}`);\n                    reject();\n                };\n                img.src = value;\n            });\n            imageLoadPromises.push(imagePromise);\n        } else {\n            processedUniforms[key] = value;\n        }\n    });\n    await Promise.all(imageLoadPromises);\n    return processedUniforms;\n}\nconst ShaderMount = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function ShaderMountImpl({ fragmentShader, uniforms: uniformsProp, webGlContextAttributes, speed = 0, frame = 0, width, height, minPixelRatio, maxPixelCount, style, ...divProps }, forwardedRef) {\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const divRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shaderMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const webGlContextAttributesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(webGlContextAttributes);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const initShader = async ()=>{\n            const uniforms = await processUniforms(uniformsProp);\n            if (divRef.current && !shaderMountRef.current) {\n                shaderMountRef.current = new _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.ShaderMount(divRef.current, fragmentShader, uniforms, webGlContextAttributesRef.current, speed, frame, minPixelRatio, maxPixelCount);\n                setIsInitialized(true);\n            }\n        };\n        initShader();\n        return ()=>{\n            shaderMountRef.current?.dispose();\n            shaderMountRef.current = null;\n        };\n    }, [\n        fragmentShader\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let isStale = false;\n        const updateUniforms = async ()=>{\n            const uniforms = await processUniforms(uniformsProp);\n            if (!isStale) {\n                shaderMountRef.current?.setUniforms(uniforms);\n            }\n        };\n        updateUniforms();\n        return ()=>{\n            isStale = true;\n        };\n    }, [\n        uniformsProp,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setSpeed(speed);\n    }, [\n        speed,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n    }, [\n        maxPixelCount,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n    }, [\n        minPixelRatio,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        shaderMountRef.current?.setFrame(frame);\n    }, [\n        frame,\n        isInitialized\n    ]);\n    const mergedRef = (0,_use_merge_refs_js__WEBPACK_IMPORTED_MODULE_4__.useMergeRefs)([\n        divRef,\n        forwardedRef\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: mergedRef,\n        style: width !== void 0 || height !== void 0 ? {\n            width,\n            height,\n            ...style\n        } : style,\n        ...divProps\n    });\n});\nShaderMount.displayName = \"ShaderMount\";\n //# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzsySEFFd0Q7QUFPakQ7QUFDc0I7QUEwTXZCO0FBbktOLGVBQWVTLGdCQUFnQkMsWUFBQTtJQUM3QixNQUFNQyxvQkFBb0IsQ0FBQztJQUMzQixNQUFNQyxvQkFBcUMsRUFBQztJQUU1QyxNQUFNQyxhQUFhLENBQUNDO1FBQ2xCLElBQUk7WUFFRixJQUFJQSxJQUFJQyxVQUFBLENBQVcsTUFBTSxPQUFPO1lBRWhDLElBQUlDLElBQUlGO1lBQ1IsT0FBTztRQUNULFNBQVE7WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE1BQU1HLGdCQUFnQixDQUFDSDtRQUNyQixJQUFJO1lBQ0YsSUFBSUEsSUFBSUMsVUFBQSxDQUFXLE1BQU0sT0FBTztZQUNoQyxNQUFNRyxZQUFZLElBQUlGLElBQUlGLEtBQUtLLE9BQU9DLFFBQUEsQ0FBU0MsTUFBTTtZQUNyRCxPQUFPSCxVQUFVRyxNQUFBLEtBQVdGLE9BQU9DLFFBQUEsQ0FBU0MsTUFBQTtRQUM5QyxTQUFRO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQUMsT0FBT0MsT0FBQSxDQUFRYixjQUFjYyxPQUFBLENBQVEsQ0FBQyxDQUFDQyxLQUFLQyxNQUFLO1FBQy9DLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBRTdCLElBQUksQ0FBQ0EsT0FBTztnQkFDVmYsaUJBQUEsQ0FBa0JjLElBQUcsR0FBSW5CLG9FQUFhQTtnQkFDdEM7WUFDRjtZQUdBLElBQUksQ0FBQ08sV0FBV2EsUUFBUTtnQkFDdEJDLFFBQVFDLElBQUEsQ0FBSyxZQUFZSCxJQUFHLHFCQUFzQkMsTUFBSywyQkFBNEI7Z0JBQ25GO1lBQ0Y7WUFFQSxNQUFNRyxlQUFlLElBQUlDLFFBQWMsQ0FBQ0MsU0FBU0M7Z0JBQy9DLE1BQU1DLE1BQU0sSUFBSUM7Z0JBQ2hCLElBQUlqQixjQUFjUyxRQUFRO29CQUN4Qk8sSUFBSUUsV0FBQSxHQUFjO2dCQUNwQjtnQkFDQUYsSUFBSUcsTUFBQSxHQUFTO29CQUNYekIsaUJBQUEsQ0FBa0JjLElBQUcsR0FBSVE7b0JBQ3pCRjtnQkFDRjtnQkFDQUUsSUFBSUksT0FBQSxHQUFVO29CQUNaVixRQUFRVyxLQUFBLENBQU0sbURBQW1EWixNQUFLLENBQUU7b0JBQ3hFTTtnQkFDRjtnQkFDQUMsSUFBSU0sR0FBQSxHQUFNYjtZQUNaO1lBQ0FkLGtCQUFrQjRCLElBQUEsQ0FBS1g7UUFDekIsT0FBTztZQUNMbEIsaUJBQUEsQ0FBa0JjLElBQUcsR0FBSUM7UUFDM0I7SUFDRjtJQUVBLE1BQU1JLFFBQVFXLEdBQUEsQ0FBSTdCO0lBQ2xCLE9BQU9EO0FBQ1Q7QUFNTyxNQUFNUCw0QkFBMENGLGlEQUFVQSxDQUMvRCxTQUFTd0MsZ0JBQ1AsRUFDRUMsY0FBQSxFQUNBQyxVQUFVbEMsWUFBQSxFQUNWbUMsc0JBQUEsRUFDQUMsUUFBUSxHQUNSQyxRQUFRLEdBQ1JDLEtBQUEsRUFDQUMsTUFBQSxFQUNBQyxhQUFBLEVBQ0FDLGFBQUEsRUFDQUMsS0FBQSxFQUNBLEdBQUdDLFVBQ0wsRUFDQUMsWUFBQTtJQUVBLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWdCLEdBQUlyRCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNc0QsU0FBU3hELDZDQUFNQSxDQUFxQjtJQUMxQyxNQUFNeUQsaUJBQTZEekQsNkNBQU1BLENBQXFCO0lBQzlGLE1BQU0wRCw0QkFBNEIxRCw2Q0FBTUEsQ0FBQzRDO0lBR3pDN0MsZ0RBQVNBLENBQUM7UUFDUixNQUFNNEQsYUFBYTtZQUNqQixNQUFNaEIsV0FBVyxNQUFNbkMsZ0JBQWdCQztZQUV2QyxJQUFJK0MsT0FBT0ksT0FBQSxJQUFXLENBQUNILGVBQWVHLE9BQUEsRUFBUztnQkFDN0NILGVBQWVHLE9BQUEsR0FBVSxJQUFJeEQsOERBQWtCQSxDQUM3Q29ELE9BQU9JLE9BQUEsRUFDUGxCLGdCQUNBQyxVQUNBZSwwQkFBMEJFLE9BQUEsRUFDMUJmLE9BQ0FDLE9BQ0FHLGVBQ0FDO2dCQUdGSyxpQkFBaUI7WUFDbkI7UUFDRjtRQUVBSTtRQUVBLE9BQU87WUFDTEYsZUFBZUcsT0FBQSxFQUFTQztZQUN4QkosZUFBZUcsT0FBQSxHQUFVO1FBQzNCO0lBQ0YsR0FBRztRQUFDbEI7S0FBZTtJQUduQjNDLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSStELFVBQVU7UUFFZCxNQUFNQyxpQkFBaUI7WUFDckIsTUFBTXBCLFdBQVcsTUFBTW5DLGdCQUFnQkM7WUFFdkMsSUFBSSxDQUFDcUQsU0FBUztnQkFHWkwsZUFBZUcsT0FBQSxFQUFTSSxZQUFZckI7WUFDdEM7UUFDRjtRQUVBb0I7UUFFQSxPQUFPO1lBQ0xELFVBQVU7UUFDWjtJQUNGLEdBQUc7UUFBQ3JEO1FBQWM2QztLQUFjO0lBR2hDdkQsZ0RBQVNBLENBQUM7UUFDUjBELGVBQWVHLE9BQUEsRUFBU0ssU0FBU3BCO0lBQ25DLEdBQUc7UUFBQ0E7UUFBT1M7S0FBYztJQUd6QnZELGdEQUFTQSxDQUFDO1FBQ1IwRCxlQUFlRyxPQUFBLEVBQVNNLGlCQUFpQmhCO0lBQzNDLEdBQUc7UUFBQ0E7UUFBZUk7S0FBYztJQUdqQ3ZELGdEQUFTQSxDQUFDO1FBQ1IwRCxlQUFlRyxPQUFBLEVBQVNPLGlCQUFpQmxCO0lBQzNDLEdBQUc7UUFBQ0E7UUFBZUs7S0FBYztJQUdqQ3ZELGdEQUFTQSxDQUFDO1FBQ1IwRCxlQUFlRyxPQUFBLEVBQVNRLFNBQVN0QjtJQUNuQyxHQUFHO1FBQUNBO1FBQU9RO0tBQWM7SUFFekIsTUFBTWUsWUFBWS9ELGdFQUFZQSxDQUFDO1FBQUNrRDtRQUFRSDtLQUFhO0lBQ3JELE9BQ0UsZ0JBQUE5QyxzREFBQUEsQ0FBQztRQUNDK0QsS0FBS0Q7UUFDTGxCLE9BQU9KLFVBQVUsVUFBYUMsV0FBVyxTQUFZO1lBQUVEO1lBQU9DO1lBQVEsR0FBR0csS0FBQTtRQUFNLElBQUlBO1FBQ2xGLEdBQUdDLFFBQUE7SUFBQTtBQUdWO0FBR0ZqRCxZQUFZb0UsV0FBQSxHQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uLi9zcmMvc2hhZGVyLW1vdW50LnRzeD80MDUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgU2hhZGVyTW91bnQgYXMgU2hhZGVyTW91bnRWYW5pbGxhLFxuICBnZXRFbXB0eVBpeGVsLFxuICB0eXBlIFBhcGVyU2hhZGVyRWxlbWVudCxcbiAgdHlwZSBTaGFkZXJNb3Rpb25QYXJhbXMsXG4gIHR5cGUgU2hhZGVyTW91bnRVbmlmb3Jtcyxcbn0gZnJvbSAnQHBhcGVyLWRlc2lnbi9zaGFkZXJzJztcbmltcG9ydCB7IHVzZU1lcmdlUmVmcyB9IGZyb20gJy4vdXNlLW1lcmdlLXJlZnMuanMnO1xuXG4vKipcbiAqIFJlYWN0IFNoYWRlciBNb3VudCBjYW4gYWxzbyBhY2NlcHQgc3RyaW5ncyBhcyB1bmlmb3JtIHZhbHVlcywgd2hpY2ggd2lsbCBhc3N1bWVkIHRvIGJlIFVSTHMgYW5kIGxvYWRlZCBhcyBpbWFnZXNcbiAqXG4gKiBXZSBhY2NlcHQgdW5kZWZpbmVkIGFzIGEgY29udmVuaWVuY2UgZm9yIHNlcnZlciByZW5kZXJpbmcsIHdoZW4gc29tZSB0aGluZ3MgbWF5IGJlIHVuZGVmaW5lZFxuICogV2UganVzdCBza2lwIHNldHRpbmcgdGhlIHVuaWZvcm0gaWYgaXQncyB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSBzaGFkZXIgbW91bnQgdG8gc3RpbGwgdGFrZSB1cCBzcGFjZSBkdXJpbmcgc2VydmVyIHJlbmRlcmluZ1xuICovXG5pbnRlcmZhY2UgU2hhZGVyTW91bnRVbmlmb3Jtc1JlYWN0IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IG51bWJlcltdIHwgbnVtYmVyW11bXSB8IEhUTUxJbWFnZUVsZW1lbnQgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyTW91bnRQcm9wcyBleHRlbmRzIE9taXQ8UmVhY3QuQ29tcG9uZW50UHJvcHM8J2Rpdic+LCAnY29sb3InIHwgJ3JlZic+LCBTaGFkZXJNb3Rpb25QYXJhbXMge1xuICByZWY/OiBSZWFjdC5SZWY8UGFwZXJTaGFkZXJFbGVtZW50PjtcbiAgZnJhZ21lbnRTaGFkZXI6IHN0cmluZztcbiAgdW5pZm9ybXM6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdDtcbiAgbWluUGl4ZWxSYXRpbz86IG51bWJlcjtcbiAgbWF4UGl4ZWxDb3VudD86IG51bWJlcjtcbiAgd2ViR2xDb250ZXh0QXR0cmlidXRlcz86IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXM7XG5cbiAgLyoqIElubGluZSBDU1Mgd2lkdGggc3R5bGUgKi9cbiAgd2lkdGg/OiBzdHJpbmcgfCBudW1iZXI7XG4gIC8qKiBJbmxpbmUgQ1NTIGhlaWdodCBzdHlsZSAqL1xuICBoZWlnaHQ/OiBzdHJpbmcgfCBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyQ29tcG9uZW50UHJvcHMgZXh0ZW5kcyBPbWl0PFJlYWN0LkNvbXBvbmVudFByb3BzPCdkaXYnPiwgJ2NvbG9yJyB8ICdyZWYnPiB7XG4gIHJlZj86IFJlYWN0LlJlZjxQYXBlclNoYWRlckVsZW1lbnQ+O1xuICBtaW5QaXhlbFJhdGlvPzogbnVtYmVyO1xuICBtYXhQaXhlbENvdW50PzogbnVtYmVyO1xuICB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzPzogV2ViR0xDb250ZXh0QXR0cmlidXRlcztcblxuICAvKiogSW5saW5lIENTUyB3aWR0aCBzdHlsZSAqL1xuICB3aWR0aD86IHN0cmluZyB8IG51bWJlcjtcbiAgLyoqIElubGluZSBDU1MgaGVpZ2h0IHN0eWxlICovXG4gIGhlaWdodD86IHN0cmluZyB8IG51bWJlcjtcbn1cblxuLyoqIFBhcnNlIHRoZSBwcm92aWRlZCB1bmlmb3JtcywgdHVybmluZyBVUkwgc3RyaW5ncyBpbnRvIGxvYWRlZCBpbWFnZXMgKi9cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3A6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdCk6IFByb21pc2U8U2hhZGVyTW91bnRVbmlmb3Jtcz4ge1xuICBjb25zdCBwcm9jZXNzZWRVbmlmb3JtcyA9IHt9IGFzIFNoYWRlck1vdW50VW5pZm9ybXM7XG4gIGNvbnN0IGltYWdlTG9hZFByb21pc2VzOiBQcm9taXNlPHZvaWQ+W10gPSBbXTtcblxuICBjb25zdCBpc1ZhbGlkVXJsID0gKHVybDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEhhbmRsZSBhYnNvbHV0ZSBwYXRoc1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiB0cnVlO1xuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHZhbGlkIFVSTFxuICAgICAgbmV3IFVSTCh1cmwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGlzRXh0ZXJuYWxVcmwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgIHJldHVybiB1cmxPYmplY3Qub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBPYmplY3QuZW50cmllcyh1bmlmb3Jtc1Byb3ApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBVc2UgYSB0cmFuc3BhcmVudCBwaXhlbCBmb3IgZW1wdHkgc3RyaW5nc1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBwcm9jZXNzZWRVbmlmb3Jtc1trZXldID0gZ2V0RW1wdHlQaXhlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgVVJMIG9yIGp1c3Qgc2tpcCB0cnlpbmcgdG8gc2V0IHRoaXMgdW5pZm9ybSBlbnRpcmVseVxuICAgICAgaWYgKCFpc1ZhbGlkVXJsKHZhbHVlKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuaWZvcm0gXCIke2tleX1cIiBoYXMgaW52YWxpZCBVUkwgXCIke3ZhbHVlfVwiLiBTa2lwcGluZyBpbWFnZSBsb2FkaW5nLmApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGltYWdlUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGlmIChpc0V4dGVybmFsVXJsKHZhbHVlKSkge1xuICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgcHJvY2Vzc2VkVW5pZm9ybXNba2V5XSA9IGltZztcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBzZXQgdW5pZm9ybXMuIEZhaWxlZCB0byBsb2FkIGltYWdlIGF0ICR7dmFsdWV9YCk7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5zcmMgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgaW1hZ2VMb2FkUHJvbWlzZXMucHVzaChpbWFnZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzZWRVbmlmb3Jtc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBhd2FpdCBQcm9taXNlLmFsbChpbWFnZUxvYWRQcm9taXNlcyk7XG4gIHJldHVybiBwcm9jZXNzZWRVbmlmb3Jtcztcbn1cblxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0aGF0IG1vdW50cyBhIHNoYWRlciBhbmQgdXBkYXRlcyBpdHMgdW5pZm9ybXMgYXMgdGhlIGNvbXBvbmVudCdzIHByb3BzIGNoYW5nZVxuICogSWYgeW91IHBhc3MgYSBzdHJpbmcgYXMgYSB1bmlmb3JtIHZhbHVlLCBpdCB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgYSBVUkwgYW5kIGF0dGVtcHRlZCB0byBiZSBsb2FkZWQgYXMgYW4gaW1hZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IFNoYWRlck1vdW50OiBSZWFjdC5GQzxTaGFkZXJNb3VudFByb3BzPiA9IGZvcndhcmRSZWY8UGFwZXJTaGFkZXJFbGVtZW50LCBTaGFkZXJNb3VudFByb3BzPihcbiAgZnVuY3Rpb24gU2hhZGVyTW91bnRJbXBsKFxuICAgIHtcbiAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgdW5pZm9ybXM6IHVuaWZvcm1zUHJvcCxcbiAgICAgIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMsXG4gICAgICBzcGVlZCA9IDAsXG4gICAgICBmcmFtZSA9IDAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pblBpeGVsUmF0aW8sXG4gICAgICBtYXhQaXhlbENvdW50LFxuICAgICAgc3R5bGUsXG4gICAgICAuLi5kaXZQcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkge1xuICAgIGNvbnN0IFtpc0luaXRpYWxpemVkLCBzZXRJc0luaXRpYWxpemVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBkaXZSZWYgPSB1c2VSZWY8UGFwZXJTaGFkZXJFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBzaGFkZXJNb3VudFJlZjogUmVhY3QuUmVmT2JqZWN0PFNoYWRlck1vdW50VmFuaWxsYSB8IG51bGw+ID0gdXNlUmVmPFNoYWRlck1vdW50VmFuaWxsYT4obnVsbCk7XG4gICAgY29uc3Qgd2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZiA9IHVzZVJlZih3ZWJHbENvbnRleHRBdHRyaWJ1dGVzKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIFNoYWRlck1vdW50VmFuaWxsYVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBpbml0U2hhZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IGF3YWl0IHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3ApO1xuXG4gICAgICAgIGlmIChkaXZSZWYuY3VycmVudCAmJiAhc2hhZGVyTW91bnRSZWYuY3VycmVudCkge1xuICAgICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQgPSBuZXcgU2hhZGVyTW91bnRWYW5pbGxhKFxuICAgICAgICAgICAgZGl2UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgICAgd2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgc3BlZWQsXG4gICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgIG1pblBpeGVsUmF0aW8sXG4gICAgICAgICAgICBtYXhQaXhlbENvdW50XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHNldElzSW5pdGlhbGl6ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGluaXRTaGFkZXIoKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uZGlzcG9zZSgpO1xuICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSwgW2ZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAvLyBVbmlmb3Jtc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgaXNTdGFsZSA9IGZhbHNlO1xuXG4gICAgICBjb25zdCB1cGRhdGVVbmlmb3JtcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5pZm9ybXMgPSBhd2FpdCBwcm9jZXNzVW5pZm9ybXModW5pZm9ybXNQcm9wKTtcblxuICAgICAgICBpZiAoIWlzU3RhbGUpIHtcbiAgICAgICAgICAvLyBXZSBvbmx5IHVzZSB0aGUgZnJlc2hlc3QgdW5pZm9ybXMgb3RoZXJ3aXNlIHdlIGNhbiBnZXQgaW50byByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAvLyBpZiBzb21lIHVuaWZvcm1zIChpbWFnZXMhKSB0YWtlIGxvbmdlciB0byBsb2FkIGluIHN1YnNlcXVlbnQgZWZmZWN0IHJ1bnMuXG4gICAgICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB1cGRhdGVVbmlmb3JtcygpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpc1N0YWxlID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSwgW3VuaWZvcm1zUHJvcCwgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgLy8gU3BlZWRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0U3BlZWQoc3BlZWQpO1xuICAgIH0sIFtzcGVlZCwgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgLy8gTWF4IFBpeGVsIENvdW50XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldE1heFBpeGVsQ291bnQobWF4UGl4ZWxDb3VudCk7XG4gICAgfSwgW21heFBpeGVsQ291bnQsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIE1pbiBQaXhlbCBSYXRpb1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRNaW5QaXhlbFJhdGlvKG1pblBpeGVsUmF0aW8pO1xuICAgIH0sIFttaW5QaXhlbFJhdGlvLCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICAvLyBGcmFtZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRGcmFtZShmcmFtZSk7XG4gICAgfSwgW2ZyYW1lLCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZVJlZnMoW2RpdlJlZiwgZm9yd2FyZGVkUmVmXSkgYXMgdW5rbm93biBhcyBSZWFjdC5SZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQ+O1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17bWVyZ2VkUmVmfVxuICAgICAgICBzdHlsZT17d2lkdGggIT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IHsgd2lkdGgsIGhlaWdodCwgLi4uc3R5bGUgfSA6IHN0eWxlfVxuICAgICAgICB7Li4uZGl2UHJvcHN9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbik7XG5cblNoYWRlck1vdW50LmRpc3BsYXlOYW1lID0gJ1NoYWRlck1vdW50JztcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJmb3J3YXJkUmVmIiwidXNlU3RhdGUiLCJTaGFkZXJNb3VudCIsIlNoYWRlck1vdW50VmFuaWxsYSIsImdldEVtcHR5UGl4ZWwiLCJ1c2VNZXJnZVJlZnMiLCJqc3giLCJwcm9jZXNzVW5pZm9ybXMiLCJ1bmlmb3Jtc1Byb3AiLCJwcm9jZXNzZWRVbmlmb3JtcyIsImltYWdlTG9hZFByb21pc2VzIiwiaXNWYWxpZFVybCIsInVybCIsInN0YXJ0c1dpdGgiLCJVUkwiLCJpc0V4dGVybmFsVXJsIiwidXJsT2JqZWN0Iiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwiY29uc29sZSIsIndhcm4iLCJpbWFnZVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJvbmxvYWQiLCJvbmVycm9yIiwiZXJyb3IiLCJzcmMiLCJwdXNoIiwiYWxsIiwiU2hhZGVyTW91bnRJbXBsIiwiZnJhZ21lbnRTaGFkZXIiLCJ1bmlmb3JtcyIsIndlYkdsQ29udGV4dEF0dHJpYnV0ZXMiLCJzcGVlZCIsImZyYW1lIiwid2lkdGgiLCJoZWlnaHQiLCJtaW5QaXhlbFJhdGlvIiwibWF4UGl4ZWxDb3VudCIsInN0eWxlIiwiZGl2UHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJpc0luaXRpYWxpemVkIiwic2V0SXNJbml0aWFsaXplZCIsImRpdlJlZiIsInNoYWRlck1vdW50UmVmIiwid2ViR2xDb250ZXh0QXR0cmlidXRlc1JlZiIsImluaXRTaGFkZXIiLCJjdXJyZW50IiwiZGlzcG9zZSIsImlzU3RhbGUiLCJ1cGRhdGVVbmlmb3JtcyIsInNldFVuaWZvcm1zIiwic2V0U3BlZWQiLCJzZXRNYXhQaXhlbENvdW50Iiwic2V0TWluUGl4ZWxSYXRpbyIsInNldEZyYW1lIiwibWVyZ2VkUmVmIiwicmVmIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/dithering.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shaders/dithering.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dithering: () => (/* binding */ Dithering),\n/* harmony export */   bugsPreset: () => (/* binding */ bugsPreset),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset),\n/* harmony export */   ditheringPresets: () => (/* binding */ ditheringPresets),\n/* harmony export */   ripplePreset: () => (/* binding */ ripplePreset),\n/* harmony export */   sinePreset: () => (/* binding */ sinePreset),\n/* harmony export */   swirlPreset: () => (/* binding */ swirlPreset),\n/* harmony export */   warpPreset: () => (/* binding */ warpPreset)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shader_mount_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shader-mount.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shaders/dithering.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\n\n\n\nconst defaultPreset = {\n  name: \"Default\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    scale: 0.6,\n    colorBack: \"#000000\",\n    colorFront: \"#00b2ff\",\n    shape: \"sphere\",\n    type: \"4x4\",\n    size: 2\n  }\n};\nconst sinePreset = {\n  name: \"Sine Wave\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#730d54\",\n    colorFront: \"#00becc\",\n    shape: \"wave\",\n    type: \"4x4\",\n    size: 11,\n    scale: 1.2\n  }\n};\nconst bugsPreset = {\n  name: \"Bugs\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultPatternSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#000000\",\n    colorFront: \"#008000\",\n    shape: \"dots\",\n    type: \"random\",\n    size: 9\n  }\n};\nconst ripplePreset = {\n  name: \"Ripple\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#603520\",\n    colorFront: \"#c67953\",\n    shape: \"ripple\",\n    type: \"2x2\",\n    size: 3\n  }\n};\nconst swirlPreset = {\n  name: \"Swirl\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#00000000\",\n    colorFront: \"#47a8e1\",\n    shape: \"swirl\",\n    type: \"8x8\",\n    size: 2\n  }\n};\nconst warpPreset = {\n  name: \"Warp\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colorBack: \"#301c2a\",\n    colorFront: \"#56ae6c\",\n    shape: \"warp\",\n    type: \"4x4\",\n    size: 2.5\n  }\n};\nconst ditheringPresets = [\n  defaultPreset,\n  warpPreset,\n  sinePreset,\n  ripplePreset,\n  bugsPreset,\n  swirlPreset\n];\nconst Dithering = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function DitheringImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colorBack = defaultPreset.params.colorBack,\n  colorFront = defaultPreset.params.colorFront,\n  shape = defaultPreset.params.shape,\n  type = defaultPreset.params.type,\n  pxSize,\n  size = pxSize === void 0 ? defaultPreset.params.size : pxSize,\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString)(colorBack),\n    u_colorFront: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString)(colorFront),\n    u_shape: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__.DitheringShapes[shape],\n    u_type: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__.DitheringTypes[type],\n    u_pxSize: size,\n    // Sizing uniforms\n    u_fit: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_shader_mount_js__WEBPACK_IMPORTED_MODULE_5__.ShaderMount, { ...props, speed, frame, fragmentShader: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__.ditheringFragmentShader, uniforms });\n});\n\n//# sourceMappingURL=dithering.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9kaXRoZXJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDb0I7QUFRbEI7QUFDeUI7QUFDaEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RUFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHVFQUFvQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUVBQW9CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLCtFQUF3QjtBQUN6QyxrQkFBa0IsK0VBQXdCO0FBQzFDLGFBQWEsa0VBQWU7QUFDNUIsWUFBWSxpRUFBYztBQUMxQjtBQUNBO0FBQ0EsV0FBVyxtRUFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFHLENBQUMseURBQVcsSUFBSSx3Q0FBd0MsMEVBQXVCLFlBQVk7QUFDdkgsQ0FBQztBQVVDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy1yZWFjdC9kaXN0L3NoYWRlcnMvZGl0aGVyaW5nLmpzPzM5M2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFNoYWRlck1vdW50IH0gZnJvbSBcIi4uL3NoYWRlci1tb3VudC5qc1wiO1xuaW1wb3J0IHtcbiAgZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nLFxuICBkaXRoZXJpbmdGcmFnbWVudFNoYWRlcixcbiAgU2hhZGVyRml0T3B0aW9ucyxcbiAgZGVmYXVsdFBhdHRlcm5TaXppbmcsXG4gIGRlZmF1bHRPYmplY3RTaXppbmcsXG4gIERpdGhlcmluZ1R5cGVzXG59IGZyb20gXCJAcGFwZXItZGVzaWduL3NoYWRlcnNcIjtcbmltcG9ydCB7IERpdGhlcmluZ1NoYXBlcyB9IGZyb20gXCJAcGFwZXItZGVzaWduL3NoYWRlcnNcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY29uc3QgZGVmYXVsdFByZXNldCA9IHtcbiAgbmFtZTogXCJEZWZhdWx0XCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRQYXR0ZXJuU2l6aW5nLFxuICAgIHNwZWVkOiAxLFxuICAgIGZyYW1lOiAwLFxuICAgIHNjYWxlOiAwLjYsXG4gICAgY29sb3JCYWNrOiBcIiMwMDAwMDBcIixcbiAgICBjb2xvckZyb250OiBcIiMwMGIyZmZcIixcbiAgICBzaGFwZTogXCJzcGhlcmVcIixcbiAgICB0eXBlOiBcIjR4NFwiLFxuICAgIHNpemU6IDJcbiAgfVxufTtcbmNvbnN0IHNpbmVQcmVzZXQgPSB7XG4gIG5hbWU6IFwiU2luZSBXYXZlXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRQYXR0ZXJuU2l6aW5nLFxuICAgIHNwZWVkOiAxLFxuICAgIGZyYW1lOiAwLFxuICAgIGNvbG9yQmFjazogXCIjNzMwZDU0XCIsXG4gICAgY29sb3JGcm9udDogXCIjMDBiZWNjXCIsXG4gICAgc2hhcGU6IFwid2F2ZVwiLFxuICAgIHR5cGU6IFwiNHg0XCIsXG4gICAgc2l6ZTogMTEsXG4gICAgc2NhbGU6IDEuMlxuICB9XG59O1xuY29uc3QgYnVnc1ByZXNldCA9IHtcbiAgbmFtZTogXCJCdWdzXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRQYXR0ZXJuU2l6aW5nLFxuICAgIHNwZWVkOiAxLFxuICAgIGZyYW1lOiAwLFxuICAgIGNvbG9yQmFjazogXCIjMDAwMDAwXCIsXG4gICAgY29sb3JGcm9udDogXCIjMDA4MDAwXCIsXG4gICAgc2hhcGU6IFwiZG90c1wiLFxuICAgIHR5cGU6IFwicmFuZG9tXCIsXG4gICAgc2l6ZTogOVxuICB9XG59O1xuY29uc3QgcmlwcGxlUHJlc2V0ID0ge1xuICBuYW1lOiBcIlJpcHBsZVwiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0T2JqZWN0U2l6aW5nLFxuICAgIHNwZWVkOiAxLFxuICAgIGZyYW1lOiAwLFxuICAgIGNvbG9yQmFjazogXCIjNjAzNTIwXCIsXG4gICAgY29sb3JGcm9udDogXCIjYzY3OTUzXCIsXG4gICAgc2hhcGU6IFwicmlwcGxlXCIsXG4gICAgdHlwZTogXCIyeDJcIixcbiAgICBzaXplOiAzXG4gIH1cbn07XG5jb25zdCBzd2lybFByZXNldCA9IHtcbiAgbmFtZTogXCJTd2lybFwiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0T2JqZWN0U2l6aW5nLFxuICAgIHNwZWVkOiAxLFxuICAgIGZyYW1lOiAwLFxuICAgIGNvbG9yQmFjazogXCIjMDAwMDAwMDBcIixcbiAgICBjb2xvckZyb250OiBcIiM0N2E4ZTFcIixcbiAgICBzaGFwZTogXCJzd2lybFwiLFxuICAgIHR5cGU6IFwiOHg4XCIsXG4gICAgc2l6ZTogMlxuICB9XG59O1xuY29uc3Qgd2FycFByZXNldCA9IHtcbiAgbmFtZTogXCJXYXJwXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc3BlZWQ6IDEsXG4gICAgZnJhbWU6IDAsXG4gICAgY29sb3JCYWNrOiBcIiMzMDFjMmFcIixcbiAgICBjb2xvckZyb250OiBcIiM1NmFlNmNcIixcbiAgICBzaGFwZTogXCJ3YXJwXCIsXG4gICAgdHlwZTogXCI0eDRcIixcbiAgICBzaXplOiAyLjVcbiAgfVxufTtcbmNvbnN0IGRpdGhlcmluZ1ByZXNldHMgPSBbXG4gIGRlZmF1bHRQcmVzZXQsXG4gIHdhcnBQcmVzZXQsXG4gIHNpbmVQcmVzZXQsXG4gIHJpcHBsZVByZXNldCxcbiAgYnVnc1ByZXNldCxcbiAgc3dpcmxQcmVzZXRcbl07XG5jb25zdCBEaXRoZXJpbmcgPSBtZW1vKGZ1bmN0aW9uIERpdGhlcmluZ0ltcGwoe1xuICAvLyBPd24gcHJvcHNcbiAgc3BlZWQgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zcGVlZCxcbiAgZnJhbWUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5mcmFtZSxcbiAgY29sb3JCYWNrID0gZGVmYXVsdFByZXNldC5wYXJhbXMuY29sb3JCYWNrLFxuICBjb2xvckZyb250ID0gZGVmYXVsdFByZXNldC5wYXJhbXMuY29sb3JGcm9udCxcbiAgc2hhcGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zaGFwZSxcbiAgdHlwZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnR5cGUsXG4gIHB4U2l6ZSxcbiAgc2l6ZSA9IHB4U2l6ZSA9PT0gdm9pZCAwID8gZGVmYXVsdFByZXNldC5wYXJhbXMuc2l6ZSA6IHB4U2l6ZSxcbiAgLy8gU2l6aW5nIHByb3BzXG4gIGZpdCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmZpdCxcbiAgc2NhbGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zY2FsZSxcbiAgcm90YXRpb24gPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5yb3RhdGlvbixcbiAgb3JpZ2luWCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9yaWdpblgsXG4gIG9yaWdpblkgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vcmlnaW5ZLFxuICBvZmZzZXRYID0gZGVmYXVsdFByZXNldC5wYXJhbXMub2Zmc2V0WCxcbiAgb2Zmc2V0WSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9mZnNldFksXG4gIHdvcmxkV2lkdGggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy53b3JsZFdpZHRoLFxuICB3b3JsZEhlaWdodCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLndvcmxkSGVpZ2h0LFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAvLyBPd24gdW5pZm9ybXNcbiAgICB1X2NvbG9yQmFjazogZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yQmFjayksXG4gICAgdV9jb2xvckZyb250OiBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcoY29sb3JGcm9udCksXG4gICAgdV9zaGFwZTogRGl0aGVyaW5nU2hhcGVzW3NoYXBlXSxcbiAgICB1X3R5cGU6IERpdGhlcmluZ1R5cGVzW3R5cGVdLFxuICAgIHVfcHhTaXplOiBzaXplLFxuICAgIC8vIFNpemluZyB1bmlmb3Jtc1xuICAgIHVfZml0OiBTaGFkZXJGaXRPcHRpb25zW2ZpdF0sXG4gICAgdV9zY2FsZTogc2NhbGUsXG4gICAgdV9yb3RhdGlvbjogcm90YXRpb24sXG4gICAgdV9vZmZzZXRYOiBvZmZzZXRYLFxuICAgIHVfb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICB1X29yaWdpblg6IG9yaWdpblgsXG4gICAgdV9vcmlnaW5ZOiBvcmlnaW5ZLFxuICAgIHVfd29ybGRXaWR0aDogd29ybGRXaWR0aCxcbiAgICB1X3dvcmxkSGVpZ2h0OiB3b3JsZEhlaWdodFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTaGFkZXJNb3VudCwgeyAuLi5wcm9wcywgc3BlZWQsIGZyYW1lLCBmcmFnbWVudFNoYWRlcjogZGl0aGVyaW5nRnJhZ21lbnRTaGFkZXIsIHVuaWZvcm1zIH0pO1xufSk7XG5leHBvcnQge1xuICBEaXRoZXJpbmcsXG4gIGJ1Z3NQcmVzZXQsXG4gIGRlZmF1bHRQcmVzZXQsXG4gIGRpdGhlcmluZ1ByZXNldHMsXG4gIHJpcHBsZVByZXNldCxcbiAgc2luZVByZXNldCxcbiAgc3dpcmxQcmVzZXQsXG4gIHdhcnBQcmVzZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXRoZXJpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/dithering.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nfunction useMergeRefs(refs) {\n  const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return typeof refCleanup === \"function\" ? refCleanup : () => {\n          refCallback(null);\n        };\n      }\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    });\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n  }, refs);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = void 0;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    };\n  }, refs);\n}\n\n//# sourceMappingURL=use-merge-refs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7QUFDQSxxQkFBcUIseUNBQVk7QUFDakMsb0JBQW9CLDhDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMENBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanM/Y2YwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICBjb25zdCBjbGVhbnVwUmVmID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gIGNvbnN0IHJlZkVmZmVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbnN0YW5jZSkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBzID0gcmVmcy5tYXAoKHJlZikgPT4ge1xuICAgICAgaWYgKHJlZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVmQ2FsbGJhY2sgPSByZWY7XG4gICAgICAgIGNvbnN0IHJlZkNsZWFudXAgPSByZWZDYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmQ2xlYW51cCA9PT0gXCJmdW5jdGlvblwiID8gcmVmQ2xlYW51cCA6ICgpID0+IHtcbiAgICAgICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwcy5mb3JFYWNoKChyZWZDbGVhbnVwKSA9PiByZWZDbGVhbnVwPy4oKSk7XG4gICAgfTtcbiAgfSwgcmVmcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVmcy5ldmVyeSgocmVmKSA9PiByZWYgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoY2xlYW51cFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCgpO1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSByZWZFZmZlY3QodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIHJlZnMpO1xufVxuZXhwb3J0IHtcbiAgdXNlTWVyZ2VSZWZzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlLXJlZnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-empty-pixel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEmptyPixel: () => (/* binding */ getEmptyPixel)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getEmptyPixel() {\n  if (typeof window === \"undefined\") {\n    console.warn(\"Paper Shaders: can\\u2019t create an image on the server\");\n    return void 0;\n  }\n  const img = new Image();\n  img.src = emptyPixel;\n  return img;\n}\nconst emptyPixel = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n//# sourceMappingURL=get-empty-pixel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LWVtcHR5LXBpeGVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFHakM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LWVtcHR5LXBpeGVsLmpzPzI2ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmZ1bmN0aW9uIGdldEVtcHR5UGl4ZWwoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGFwZXIgU2hhZGVyczogY2FuXFx1MjAxOXQgY3JlYXRlIGFuIGltYWdlIG9uIHRoZSBzZXJ2ZXJcIik7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLnNyYyA9IGVtcHR5UGl4ZWw7XG4gIHJldHVybiBpbWc7XG59XG5jb25zdCBlbXB0eVBpeGVsID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuZXhwb3J0IHtcbiAgZ2V0RW1wdHlQaXhlbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1lbXB0eS1waXhlbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-empty-pixel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getShaderColorFromString: () => (/* binding */ getShaderColorFromString)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderColorFromString(colorString) {\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString;\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n  if (typeof colorString !== \"string\") {\n    return fallbackColor;\n  }\n  let r, g, b, a = 1;\n  if (colorString.startsWith(\"#\")) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith(\"rgb\")) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith(\"hsl\")) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error(\"Unsupported color format\", colorString);\n    return fallbackColor;\n  }\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\nfunction hexToRgba(hex) {\n  hex = hex.replace(/^#/, \"\");\n  if (hex.length === 3) {\n    hex = hex.split(\"\").map((char) => char + char).join(\"\");\n  }\n  if (hex.length === 6) {\n    hex = hex + \"ff\";\n  }\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n  return [r, g, b, a];\n}\nfunction parseRgba(rgba) {\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\") / 255,\n    parseInt(match[2] ?? \"0\") / 255,\n    parseInt(match[3] ?? \"0\") / 255,\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction parseHsla(hsla) {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\"),\n    parseInt(match[2] ?? \"0\"),\n    parseInt(match[3] ?? \"0\"),\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction hslaToRgba(hsla) {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = lDecimal;\n  } else {\n    const hue2rgb = (p2, q2, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n      if (t < 1 / 2) return q2;\n      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n      return p2;\n    };\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n  return [r, g, b, a];\n}\nconst clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nconst fallbackColor = [0, 0, 0, 1];\n\n//# sourceMappingURL=get-shader-color-from-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L2dldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanM/MDU3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuZnVuY3Rpb24gZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yU3RyaW5nKSkge1xuICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDQpIHJldHVybiBjb2xvclN0cmluZztcbiAgICBpZiAoY29sb3JTdHJpbmcubGVuZ3RoID09PSAzKSByZXR1cm4gWy4uLmNvbG9yU3RyaW5nLCAxXTtcbiAgICByZXR1cm4gZmFsbGJhY2tDb2xvcjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbG9yU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29sb3I7XG4gIH1cbiAgbGV0IHIsIGcsIGIsIGEgPSAxO1xuICBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoZXhUb1JnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJyZ2JcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBwYXJzZVJnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJoc2xcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoc2xhVG9SZ2JhKHBhcnNlSHNsYShjb2xvclN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBjb2xvciBmb3JtYXRcIiwgY29sb3JTdHJpbmcpO1xuICAgIHJldHVybiBmYWxsYmFja0NvbG9yO1xuICB9XG4gIHJldHVybiBbY2xhbXAociwgMCwgMSksIGNsYW1wKGcsIDAsIDEpLCBjbGFtcChiLCAwLCAxKSwgY2xhbXAoYSwgMCwgMSldO1xufVxuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleCkge1xuICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCBcIlwiKTtcbiAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICBoZXggPSBoZXguc3BsaXQoXCJcIikubWFwKChjaGFyKSA9PiBjaGFyICsgY2hhcikuam9pbihcIlwiKTtcbiAgfVxuICBpZiAoaGV4Lmxlbmd0aCA9PT0gNikge1xuICAgIGhleCA9IGhleCArIFwiZmZcIjtcbiAgfVxuICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNikgLyAyNTU7XG4gIGNvbnN0IGcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KSAvIDI1NTtcbiAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zbGljZSg0LCA2KSwgMTYpIC8gMjU1O1xuICBjb25zdCBhID0gcGFyc2VJbnQoaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTU7XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5mdW5jdGlvbiBwYXJzZVJnYmEocmdiYSkge1xuICBjb25zdCBtYXRjaCA9IHJnYmEubWF0Y2goL15yZ2JhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFswLTkuXSspKT9cXHMqXFwpJC9pKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIFswLCAwLCAwLCAxXTtcbiAgcmV0dXJuIFtcbiAgICBwYXJzZUludChtYXRjaFsxXSA/PyBcIjBcIikgLyAyNTUsXG4gICAgcGFyc2VJbnQobWF0Y2hbMl0gPz8gXCIwXCIpIC8gMjU1LFxuICAgIHBhcnNlSW50KG1hdGNoWzNdID8/IFwiMFwiKSAvIDI1NSxcbiAgICBtYXRjaFs0XSA9PT0gdm9pZCAwID8gMSA6IHBhcnNlRmxvYXQobWF0Y2hbNF0pXG4gIF07XG59XG5mdW5jdGlvbiBwYXJzZUhzbGEoaHNsYSkge1xuICBjb25zdCBtYXRjaCA9IGhzbGEubWF0Y2goL15oc2xhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqKD86LFxccyooWzAtOS5dKykpP1xccypcXCkkL2kpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gWzAsIDAsIDAsIDFdO1xuICByZXR1cm4gW1xuICAgIHBhcnNlSW50KG1hdGNoWzFdID8/IFwiMFwiKSxcbiAgICBwYXJzZUludChtYXRjaFsyXSA/PyBcIjBcIiksXG4gICAgcGFyc2VJbnQobWF0Y2hbM10gPz8gXCIwXCIpLFxuICAgIG1hdGNoWzRdID09PSB2b2lkIDAgPyAxIDogcGFyc2VGbG9hdChtYXRjaFs0XSlcbiAgXTtcbn1cbmZ1bmN0aW9uIGhzbGFUb1JnYmEoaHNsYSkge1xuICBjb25zdCBbaCwgcywgbCwgYV0gPSBoc2xhO1xuICBjb25zdCBoRGVjaW1hbCA9IGggLyAzNjA7XG4gIGNvbnN0IHNEZWNpbWFsID0gcyAvIDEwMDtcbiAgY29uc3QgbERlY2ltYWwgPSBsIC8gMTAwO1xuICBsZXQgciwgZywgYjtcbiAgaWYgKHMgPT09IDApIHtcbiAgICByID0gZyA9IGIgPSBsRGVjaW1hbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBodWUycmdiID0gKHAyLCBxMiwgdCkgPT4ge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwMiArIChxMiAtIHAyKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHEyO1xuICAgICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAyICsgKHEyIC0gcDIpICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHAyO1xuICAgIH07XG4gICAgY29uc3QgcSA9IGxEZWNpbWFsIDwgMC41ID8gbERlY2ltYWwgKiAoMSArIHNEZWNpbWFsKSA6IGxEZWNpbWFsICsgc0RlY2ltYWwgLSBsRGVjaW1hbCAqIHNEZWNpbWFsO1xuICAgIGNvbnN0IHAgPSAyICogbERlY2ltYWwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsICsgMSAvIDMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoRGVjaW1hbCAtIDEgLyAzKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuY29uc3QgY2xhbXAgPSAobiwgbWluLCBtYXgpID0+IE1hdGgubWluKE1hdGgubWF4KG4sIG1pbiksIG1heCk7XG5jb25zdCBmYWxsYmFja0NvbG9yID0gWzAsIDAsIDAsIDFdO1xuZXhwb3J0IHtcbiAgY2xhbXAsXG4gIGdldFNoYWRlckNvbG9yRnJvbVN0cmluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-mount.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount),\n/* harmony export */   isPaperShaderElement: () => (/* binding */ isPaperShaderElement)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nconst DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;\nclass ShaderMount {\n  parentElement;\n  canvasElement;\n  gl;\n  program = null;\n  uniformLocations = {};\n  /** The fragment shader that we are using */\n  fragmentShader;\n  /** Stores the RAF for the render loop */\n  rafId = null;\n  /** Time of the last rendered frame */\n  lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  currentFrame = 0;\n  /** The speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  speed = 0;\n  /** Actual speed used that accounts for document visibility (we pause the shader if the tab is hidden) */\n  currentSpeed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  providedUniforms;\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  textures = /* @__PURE__ */ new Map();\n  minPixelRatio;\n  maxPixelCount;\n  isSafari = isSafari();\n  uniformCache = {};\n  textureUnitMap = /* @__PURE__ */ new Map();\n  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement;\n    } else {\n      throw new Error(\"Paper Shaders: parent element must be an HTMLElement\");\n    }\n    if (!document.querySelector(\"style[data-paper-shader]\")) {\n      const styleElement = document.createElement(\"style\");\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute(\"data-paper-shader\", \"\");\n      document.head.prepend(styleElement);\n    }\n    const canvasElement = document.createElement(\"canvas\");\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.currentFrame = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n    const gl = canvasElement.getContext(\"webgl2\", webGlContextAttributes);\n    if (!gl) {\n      throw new Error(\"Paper Shaders: WebGL is not supported in this browser\");\n    }\n    this.gl = gl;\n    this.initProgram();\n    this.setupPositionAttribute();\n    this.setupUniforms();\n    this.setUniformValues(this.providedUniforms);\n    this.setupResizeObserver();\n    visualViewport?.addEventListener(\"resize\", this.handleVisualViewportChange);\n    this.setSpeed(speed);\n    this.parentElement.setAttribute(\"data-paper-shader\", \"\");\n    this.parentElement.paperShaderMount = this;\n    document.addEventListener(\"visibilitychange\", this.handleDocumentVisibilityChange);\n  }\n  initProgram = () => {\n    const program = createProgram(this.gl, _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__.vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n  setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n  setupUniforms = () => {\n    const uniformLocations = {\n      u_time: this.gl.getUniformLocation(this.program, \"u_time\"),\n      u_pixelRatio: this.gl.getUniformLocation(this.program, \"u_pixelRatio\"),\n      u_resolution: this.gl.getUniformLocation(this.program, \"u_resolution\")\n    };\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program, key);\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}AspectRatio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);\n      }\n    });\n    this.uniformLocations = uniformLocations;\n  };\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  renderScale = 1;\n  parentWidth = 0;\n  parentHeight = 0;\n  parentDevicePixelWidth = 0;\n  parentDevicePixelHeight = 0;\n  devicePixelsSupported = false;\n  resizeObserver = null;\n  setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        const physicalPixelSize = entry.devicePixelContentBoxSize?.[0];\n        if (physicalPixelSize !== void 0) {\n          this.devicePixelsSupported = true;\n          this.parentDevicePixelWidth = physicalPixelSize.inlineSize;\n          this.parentDevicePixelHeight = physicalPixelSize.blockSize;\n        }\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n      this.handleResize();\n    });\n    this.resizeObserver.observe(this.parentElement);\n  };\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Resize observer by itself does not react to pinch zoom, and although it usually\n  // reacts to classic browser zoom, it's not guaranteed in edge cases.\n  // Since timing between visual viewport changes and resize observer is complex\n  // and because we'd like to know the device pixel sizes of elements, we just restart\n  // the observer to get a guaranteed fresh callback regardless if it would have triggered or not.\n  handleVisualViewportChange = () => {\n    this.resizeObserver?.disconnect();\n    this.setupResizeObserver();\n  };\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  handleResize = () => {\n    let targetPixelWidth = 0;\n    let targetPixelHeight = 0;\n    const dpr = Math.max(1, window.devicePixelRatio);\n    const pinchZoom = visualViewport?.scale ?? 1;\n    if (this.devicePixelsSupported) {\n      const scaleToMeetMinPixelRatio = Math.max(1, this.minPixelRatio / dpr);\n      targetPixelWidth = this.parentDevicePixelWidth * scaleToMeetMinPixelRatio * pinchZoom;\n      targetPixelHeight = this.parentDevicePixelHeight * scaleToMeetMinPixelRatio * pinchZoom;\n    } else {\n      let targetRenderScale = Math.max(dpr, this.minPixelRatio) * pinchZoom;\n      if (this.isSafari) {\n        const zoomLevel = bestGuessBrowserZoom();\n        targetRenderScale *= Math.max(1, zoomLevel);\n      }\n      targetPixelWidth = Math.round(this.parentWidth) * targetRenderScale;\n      targetPixelHeight = Math.round(this.parentHeight) * targetRenderScale;\n    }\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const scaleToMeetMaxPixelCount = Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(targetPixelWidth * scaleToMeetMaxPixelCount);\n    const newHeight = Math.round(targetPixelHeight * scaleToMeetMaxPixelCount);\n    const newRenderScale = newWidth / Math.round(this.parentWidth);\n    if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      this.render(performance.now());\n    }\n  };\n  render = (currentTime) => {\n    if (this.hasBeenDisposed) return;\n    if (this.program === null) {\n      console.warn(\"Tried to render before program or gl was initialized\");\n      return;\n    }\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    if (this.currentSpeed !== 0) {\n      this.currentFrame += dt * this.currentSpeed;\n    }\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    this.gl.useProgram(this.program);\n    this.gl.uniform1f(this.uniformLocations.u_time, this.currentFrame * 1e-3);\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);\n      this.resolutionChanged = false;\n    }\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    if (this.currentSpeed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n  requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n  /** Creates a texture from an image and sets it into a uniform value */\n  setTextureUniform = (uniformName, image) => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n    if (!this.textureUnitMap.has(uniformName)) {\n      this.textureUnitMap.set(uniformName, this.textureUnitMap.size);\n    }\n    const textureUnit = this.textureUnitMap.get(uniformName);\n    this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    if (uniformName !== \"u_noiseTexture\") {\n      this.gl.generateMipmap(this.gl.TEXTURE_2D);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);\n    }\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error(\"Paper Shaders: WebGL error when uploading texture:\", error);\n      return;\n    }\n    this.textures.set(uniformName, texture);\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      this.gl.uniform1i(location, textureUnit);\n      const aspectRatioUniformName = `${uniformName}AspectRatio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n  /** Utility: recursive equality test for all the uniforms */\n  areUniformValuesEqual = (a, b) => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, b[i]));\n    }\n    return false;\n  };\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  setUniformValues = (updatedUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      let cacheValue = value;\n      if (value instanceof HTMLImageElement) {\n        cacheValue = `${value.src.slice(0, 200)}|${value.naturalWidth}x${value.naturalHeight}`;\n      }\n      if (this.areUniformValuesEqual(this.uniformCache[key], cacheValue)) return;\n      this.uniformCache[key] = cacheValue;\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n      if (value instanceof HTMLImageElement) {\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        let flatArray = null;\n        let valueLength = null;\n        if (value[0] !== void 0 && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => arr.length === firstChildLength)) {\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          flatArray = value;\n          valueLength = flatArray.length;\n        }\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === \"number\") {\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === \"boolean\") {\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n  /** Gets the current total animation time from 0ms */\n  getCurrentFrame = () => {\n    return this.currentFrame;\n  };\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  setFrame = (newFrame) => {\n    this.currentFrame = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n  /** Set an animation speed (or 0 to stop animation) */\n  setSpeed = (newSpeed = 1) => {\n    this.speed = newSpeed;\n    this.setCurrentSpeed(document.hidden ? 0 : newSpeed);\n  };\n  setCurrentSpeed = (newSpeed) => {\n    this.currentSpeed = newSpeed;\n    if (this.rafId === null && newSpeed !== 0) {\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n    if (this.rafId !== null && newSpeed === 0) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  setMaxPixelCount = (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {\n    this.maxPixelCount = newMaxPixelCount;\n    this.handleResize();\n  };\n  /** Set the minimum pixel ratio for the shader */\n  setMinPixelRatio = (newMinPixelRatio = 2) => {\n    this.minPixelRatio = newMinPixelRatio;\n    this.handleResize();\n  };\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  setUniforms = (newUniforms) => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n    this.render(performance.now());\n  };\n  handleDocumentVisibilityChange = () => {\n    this.setCurrentSpeed(document.hidden ? 0 : this.speed);\n  };\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  dispose = () => {\n    this.hasBeenDisposed = true;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n    if (this.gl && this.program) {\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.getError();\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    visualViewport?.removeEventListener(\"resize\", this.handleVisualViewportChange);\n    document.removeEventListener(\"visibilitychange\", this.handleDocumentVisibilityChange);\n    this.uniformLocations = {};\n    this.canvasElement.remove();\n    delete this.parentElement.paperShaderMount;\n  };\n}\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource) {\n  const format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n  const precision = format ? format.precision : null;\n  if (precision && precision < 23) {\n    vertexShaderSource2 = vertexShaderSource2.replace(/precision\\s+(lowp|mediump)\\s+float;/g, \"precision highp float;\");\n    fragmentShaderSource = fragmentShaderSource.replace(/precision\\s+(lowp|mediump)\\s+float/g, \"precision highp float\").replace(/\\b(uniform|varying|attribute)\\s+(lowp|mediump)\\s+(\\w+)/g, \"$1 highp $3\");\n  }\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  if (!vertexShader || !fragmentShader) return null;\n  const program = gl.createProgram();\n  if (!program) return null;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  return program;\n}\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n      corner-shape: inherit;\n    }\n  }\n}`;\nfunction isPaperShaderElement(element) {\n  return \"paperShaderMount\" in element;\n}\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes(\"safari\") && !ua.includes(\"chrome\") && !ua.includes(\"android\");\n}\nfunction bestGuessBrowserZoom() {\n  const viewportScale = visualViewport?.scale ?? 1;\n  const viewportWidth = visualViewport?.width ?? window.innerWidth;\n  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  const innerWidth = viewportScale * viewportWidth + scrollbarWidth;\n  const ratio = outerWidth / innerWidth;\n  const zoomPercentageRounded = Math.round(100 * ratio);\n  if (zoomPercentageRounded % 5 === 0) {\n    return zoomPercentageRounded / 100;\n  }\n  if (zoomPercentageRounded === 33) {\n    return 1 / 3;\n  }\n  if (zoomPercentageRounded === 67) {\n    return 2 / 3;\n  }\n  if (zoomPercentageRounded === 133) {\n    return 4 / 3;\n  }\n  return ratio;\n}\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpRUFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHlFQUF5RSxJQUFJO0FBQzdFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHFEQUFxRCxJQUFJLElBQUksYUFBYTtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJCQUEyQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzP2RhMDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IHZlcnRleFNoYWRlclNvdXJjZSB9IGZyb20gXCIuL3ZlcnRleC1zaGFkZXIuanNcIjtcbmNvbnN0IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UID0gMTkyMCAqIDEwODAgKiA0O1xuY2xhc3MgU2hhZGVyTW91bnQge1xuICBwYXJlbnRFbGVtZW50O1xuICBjYW52YXNFbGVtZW50O1xuICBnbDtcbiAgcHJvZ3JhbSA9IG51bGw7XG4gIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgLyoqIFRoZSBmcmFnbWVudCBzaGFkZXIgdGhhdCB3ZSBhcmUgdXNpbmcgKi9cbiAgZnJhZ21lbnRTaGFkZXI7XG4gIC8qKiBTdG9yZXMgdGhlIFJBRiBmb3IgdGhlIHJlbmRlciBsb29wICovXG4gIHJhZklkID0gbnVsbDtcbiAgLyoqIFRpbWUgb2YgdGhlIGxhc3QgcmVuZGVyZWQgZnJhbWUgKi9cbiAgbGFzdFJlbmRlclRpbWUgPSAwO1xuICAvKiogVG90YWwgdGltZSB0aGF0IHdlIGhhdmUgcGxheWVkIGFueSBhbmltYXRpb24sIHBhc3NlZCBhcyBhIHVuaWZvcm0gdG8gdGhlIHNoYWRlciBmb3IgdGltZS1iYXNlZCBWRlggKi9cbiAgY3VycmVudEZyYW1lID0gMDtcbiAgLyoqIFRoZSBzcGVlZCB0aGF0IHdlIHByb2dyZXNzIHRocm91Z2ggYW5pbWF0aW9uIHRpbWUgKG11bHRpcGxpZXMgYnkgZGVsdGEgdGltZSBldmVyeSB1cGRhdGUpLiBBbGxvd3MgbmVnYXRpdmVzIHRvIHBsYXkgaW4gcmV2ZXJzZS4gSWYgc2V0IHRvIDAsIHJBRiB3aWxsIHN0b3AgZW50aXJlbHkgc28gc3RhdGljIHNoYWRlcnMgaGF2ZSBubyByZWN1cnJpbmcgcGVyZm9ybWFuY2UgY29zdHMgKi9cbiAgc3BlZWQgPSAwO1xuICAvKiogQWN0dWFsIHNwZWVkIHVzZWQgdGhhdCBhY2NvdW50cyBmb3IgZG9jdW1lbnQgdmlzaWJpbGl0eSAod2UgcGF1c2UgdGhlIHNoYWRlciBpZiB0aGUgdGFiIGlzIGhpZGRlbikgKi9cbiAgY3VycmVudFNwZWVkID0gMDtcbiAgLyoqIFVuaWZvcm1zIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGZvciB0aGUgc3BlY2lmaWMgc2hhZGVyIGJlaW5nIG1vdW50ZWQgKG5vdCBpbmNsdWRpbmcgdW5pZm9ybXMgdGhhdCB0aGlzIE1vdW50IGFkZHMsIGxpa2UgdGltZSBhbmQgcmVzb2x1dGlvbikgKi9cbiAgcHJvdmlkZWRVbmlmb3JtcztcbiAgLyoqIEp1c3QgYSBzYW5pdHkgY2hlY2sgdG8gbWFrZSBzdXJlIGZyYW1lcyBkb24ndCBydW4gYWZ0ZXIgd2UncmUgZGlzcG9zZWQgKi9cbiAgaGFzQmVlbkRpc3Bvc2VkID0gZmFsc2U7XG4gIC8qKiBJZiB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY2FudmFzIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlbmRlciAqL1xuICByZXNvbHV0aW9uQ2hhbmdlZCA9IHRydWU7XG4gIC8qKiBTdG9yZSB0ZXh0dXJlcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICB0ZXh0dXJlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG1pblBpeGVsUmF0aW87XG4gIG1heFBpeGVsQ291bnQ7XG4gIGlzU2FmYXJpID0gaXNTYWZhcmkoKTtcbiAgdW5pZm9ybUNhY2hlID0ge307XG4gIHRleHR1cmVVbml0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IocGFyZW50RWxlbWVudCwgZnJhZ21lbnRTaGFkZXIsIHVuaWZvcm1zLCB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzLCBzcGVlZCA9IDAsIGZyYW1lID0gMCwgbWluUGl4ZWxSYXRpbyA9IDIsIG1heFBpeGVsQ291bnQgPSBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCkge1xuICAgIGlmIChwYXJlbnRFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcGVyIFNoYWRlcnM6IHBhcmVudCBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnRcIik7XG4gICAgfVxuICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInN0eWxlW2RhdGEtcGFwZXItc2hhZGVyXVwiKSkge1xuICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGRlZmF1bHRTdHlsZTtcbiAgICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhcGVyLXNoYWRlclwiLCBcIlwiKTtcbiAgICAgIGRvY3VtZW50LmhlYWQucHJlcGVuZChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBjYW52YXNFbGVtZW50O1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5wcmVwZW5kKGNhbnZhc0VsZW1lbnQpO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcbiAgICB0aGlzLnByb3ZpZGVkVW5pZm9ybXMgPSB1bmlmb3JtcztcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lO1xuICAgIHRoaXMubWluUGl4ZWxSYXRpbyA9IG1pblBpeGVsUmF0aW87XG4gICAgdGhpcy5tYXhQaXhlbENvdW50ID0gbWF4UGl4ZWxDb3VudDtcbiAgICBjb25zdCBnbCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dChcIndlYmdsMlwiLCB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXBlciBTaGFkZXJzOiBXZWJHTCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbiAgICB9XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuaW5pdFByb2dyYW0oKTtcbiAgICB0aGlzLnNldHVwUG9zaXRpb25BdHRyaWJ1dGUoKTtcbiAgICB0aGlzLnNldHVwVW5pZm9ybXMoKTtcbiAgICB0aGlzLnNldFVuaWZvcm1WYWx1ZXModGhpcy5wcm92aWRlZFVuaWZvcm1zKTtcbiAgICB0aGlzLnNldHVwUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICB2aXN1YWxWaWV3cG9ydD8uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmhhbmRsZVZpc3VhbFZpZXdwb3J0Q2hhbmdlKTtcbiAgICB0aGlzLnNldFNwZWVkKHNwZWVkKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1wYXBlci1zaGFkZXJcIiwgXCJcIik7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnBhcGVyU2hhZGVyTW91bnQgPSB0aGlzO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMuaGFuZGxlRG9jdW1lbnRWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfVxuICBpbml0UHJvZ3JhbSA9ICgpID0+IHtcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh0aGlzLmdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIGlmICghcHJvZ3JhbSkgcmV0dXJuO1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gIH07XG4gIHNldHVwUG9zaXRpb25BdHRyaWJ1dGUgPSAoKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFstMSwgLTEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIC0xLCAxLCAxXTtcbiAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKSwgdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG4gICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiwgMiwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICB9O1xuICBzZXR1cFVuaWZvcm1zID0gKCkgPT4ge1xuICAgIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnMgPSB7XG4gICAgICB1X3RpbWU6IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3RpbWVcIiksXG4gICAgICB1X3BpeGVsUmF0aW86IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3BpeGVsUmF0aW9cIiksXG4gICAgICB1X3Jlc29sdXRpb246IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3Jlc29sdXRpb25cIilcbiAgICB9O1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMucHJvdmlkZWRVbmlmb3JtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICB1bmlmb3JtTG9jYXRpb25zW2tleV0gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIGtleSk7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvVW5pZm9ybU5hbWUgPSBgJHtrZXl9QXNwZWN0UmF0aW9gO1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW2FzcGVjdFJhdGlvVW5pZm9ybU5hbWVdID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSB1bmlmb3JtTG9jYXRpb25zO1xuICB9O1xuICAvKipcbiAgICogVGhlIHNjYWxlIHRoYXQgd2Ugc2hvdWxkIHJlbmRlciBhdC5cbiAgICogLSBVc2VkIHRvIHRhcmdldCAyeCByZW5kZXJpbmcgZXZlbiBvbiAxeCBzY3JlZW5zIGZvciBiZXR0ZXIgYW50aWFsaWFzaW5nXG4gICAqIC0gUHJldmVudHMgdGhlIHZpcnR1YWwgcmVzb2x1dGlvbiBmcm9tIGdvaW5nIGJleW9uZCB0aGUgbWF4aW11bSByZXNvbHV0aW9uXG4gICAqIC0gQWNjb3VudHMgZm9yIHRoZSBwYWdlIHpvb20gbGV2ZWwgc28gd2UgcmVuZGVyIGluIHBoeXNpY2FsIGRldmljZSBwaXhlbHMgcmF0aGVyIHRoYW4gQ1NTIHBpeGVsc1xuICAgKi9cbiAgcmVuZGVyU2NhbGUgPSAxO1xuICBwYXJlbnRXaWR0aCA9IDA7XG4gIHBhcmVudEhlaWdodCA9IDA7XG4gIHBhcmVudERldmljZVBpeGVsV2lkdGggPSAwO1xuICBwYXJlbnREZXZpY2VQaXhlbEhlaWdodCA9IDA7XG4gIGRldmljZVBpeGVsc1N1cHBvcnRlZCA9IGZhbHNlO1xuICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIHNldHVwUmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoW2VudHJ5XSkgPT4ge1xuICAgICAgaWYgKGVudHJ5Py5ib3JkZXJCb3hTaXplWzBdKSB7XG4gICAgICAgIGNvbnN0IHBoeXNpY2FsUGl4ZWxTaXplID0gZW50cnkuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZT8uWzBdO1xuICAgICAgICBpZiAocGh5c2ljYWxQaXhlbFNpemUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMuZGV2aWNlUGl4ZWxzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnBhcmVudERldmljZVBpeGVsV2lkdGggPSBwaHlzaWNhbFBpeGVsU2l6ZS5pbmxpbmVTaXplO1xuICAgICAgICAgIHRoaXMucGFyZW50RGV2aWNlUGl4ZWxIZWlnaHQgPSBwaHlzaWNhbFBpeGVsU2l6ZS5ibG9ja1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnRXaWR0aCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF0uaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5wYXJlbnRIZWlnaHQgPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdLmJsb2NrU2l6ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMucGFyZW50RWxlbWVudCk7XG4gIH07XG4gIC8vIFZpc3VhbCB2aWV3cG9ydCByZXNpemUgaGFuZGxlciwgbWFpbmx5IHVzZWQgdG8gcmVhY3QgdG8gYnJvd3NlciB6b29tIGNoYW5nZXMuXG4gIC8vIFJlc2l6ZSBvYnNlcnZlciBieSBpdHNlbGYgZG9lcyBub3QgcmVhY3QgdG8gcGluY2ggem9vbSwgYW5kIGFsdGhvdWdoIGl0IHVzdWFsbHlcbiAgLy8gcmVhY3RzIHRvIGNsYXNzaWMgYnJvd3NlciB6b29tLCBpdCdzIG5vdCBndWFyYW50ZWVkIGluIGVkZ2UgY2FzZXMuXG4gIC8vIFNpbmNlIHRpbWluZyBiZXR3ZWVuIHZpc3VhbCB2aWV3cG9ydCBjaGFuZ2VzIGFuZCByZXNpemUgb2JzZXJ2ZXIgaXMgY29tcGxleFxuICAvLyBhbmQgYmVjYXVzZSB3ZSdkIGxpa2UgdG8ga25vdyB0aGUgZGV2aWNlIHBpeGVsIHNpemVzIG9mIGVsZW1lbnRzLCB3ZSBqdXN0IHJlc3RhcnRcbiAgLy8gdGhlIG9ic2VydmVyIHRvIGdldCBhIGd1YXJhbnRlZWQgZnJlc2ggY2FsbGJhY2sgcmVnYXJkbGVzcyBpZiBpdCB3b3VsZCBoYXZlIHRyaWdnZXJlZCBvciBub3QuXG4gIGhhbmRsZVZpc3VhbFZpZXdwb3J0Q2hhbmdlID0gKCkgPT4ge1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnNldHVwUmVzaXplT2JzZXJ2ZXIoKTtcbiAgfTtcbiAgLyoqIFJlc2l6ZSBoYW5kbGVyIGZvciB3aGVuIHRoZSBjb250YWluZXIgZGl2IGNoYW5nZXMgc2l6ZSBvciB0aGUgbWF4IHBpeGVsIGNvdW50IGNoYW5nZXMgYW5kIHdlIHdhbnQgdG8gcmVzaXplIG91ciBjYW52YXMgdG8gbWF0Y2ggKi9cbiAgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIGxldCB0YXJnZXRQaXhlbFdpZHRoID0gMDtcbiAgICBsZXQgdGFyZ2V0UGl4ZWxIZWlnaHQgPSAwO1xuICAgIGNvbnN0IGRwciA9IE1hdGgubWF4KDEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICBjb25zdCBwaW5jaFpvb20gPSB2aXN1YWxWaWV3cG9ydD8uc2NhbGUgPz8gMTtcbiAgICBpZiAodGhpcy5kZXZpY2VQaXhlbHNTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHNjYWxlVG9NZWV0TWluUGl4ZWxSYXRpbyA9IE1hdGgubWF4KDEsIHRoaXMubWluUGl4ZWxSYXRpbyAvIGRwcik7XG4gICAgICB0YXJnZXRQaXhlbFdpZHRoID0gdGhpcy5wYXJlbnREZXZpY2VQaXhlbFdpZHRoICogc2NhbGVUb01lZXRNaW5QaXhlbFJhdGlvICogcGluY2hab29tO1xuICAgICAgdGFyZ2V0UGl4ZWxIZWlnaHQgPSB0aGlzLnBhcmVudERldmljZVBpeGVsSGVpZ2h0ICogc2NhbGVUb01lZXRNaW5QaXhlbFJhdGlvICogcGluY2hab29tO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGFyZ2V0UmVuZGVyU2NhbGUgPSBNYXRoLm1heChkcHIsIHRoaXMubWluUGl4ZWxSYXRpbykgKiBwaW5jaFpvb207XG4gICAgICBpZiAodGhpcy5pc1NhZmFyaSkge1xuICAgICAgICBjb25zdCB6b29tTGV2ZWwgPSBiZXN0R3Vlc3NCcm93c2VyWm9vbSgpO1xuICAgICAgICB0YXJnZXRSZW5kZXJTY2FsZSAqPSBNYXRoLm1heCgxLCB6b29tTGV2ZWwpO1xuICAgICAgfVxuICAgICAgdGFyZ2V0UGl4ZWxXaWR0aCA9IE1hdGgucm91bmQodGhpcy5wYXJlbnRXaWR0aCkgKiB0YXJnZXRSZW5kZXJTY2FsZTtcbiAgICAgIHRhcmdldFBpeGVsSGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLnBhcmVudEhlaWdodCkgKiB0YXJnZXRSZW5kZXJTY2FsZTtcbiAgICB9XG4gICAgY29uc3QgbWF4UGl4ZWxDb3VudEhlYWRyb29tID0gTWF0aC5zcXJ0KHRoaXMubWF4UGl4ZWxDb3VudCkgLyBNYXRoLnNxcnQodGFyZ2V0UGl4ZWxXaWR0aCAqIHRhcmdldFBpeGVsSGVpZ2h0KTtcbiAgICBjb25zdCBzY2FsZVRvTWVldE1heFBpeGVsQ291bnQgPSBNYXRoLm1pbigxLCBtYXhQaXhlbENvdW50SGVhZHJvb20pO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5yb3VuZCh0YXJnZXRQaXhlbFdpZHRoICogc2NhbGVUb01lZXRNYXhQaXhlbENvdW50KTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRhcmdldFBpeGVsSGVpZ2h0ICogc2NhbGVUb01lZXRNYXhQaXhlbENvdW50KTtcbiAgICBjb25zdCBuZXdSZW5kZXJTY2FsZSA9IG5ld1dpZHRoIC8gTWF0aC5yb3VuZCh0aGlzLnBhcmVudFdpZHRoKTtcbiAgICBpZiAodGhpcy5jYW52YXNFbGVtZW50LndpZHRoICE9PSBuZXdXaWR0aCB8fCB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ICE9PSBuZXdIZWlnaHQgfHwgdGhpcy5yZW5kZXJTY2FsZSAhPT0gbmV3UmVuZGVyU2NhbGUpIHtcbiAgICAgIHRoaXMucmVuZGVyU2NhbGUgPSBuZXdSZW5kZXJTY2FsZTtcbiAgICAgIHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHRoaXMucmVzb2x1dGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLmdsLmNhbnZhcy53aWR0aCwgdGhpcy5nbC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG4gIH07XG4gIHJlbmRlciA9IChjdXJyZW50VGltZSkgPT4ge1xuICAgIGlmICh0aGlzLmhhc0JlZW5EaXNwb3NlZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnByb2dyYW0gPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHJlbmRlciBiZWZvcmUgcHJvZ3JhbSBvciBnbCB3YXMgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGR0ID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RSZW5kZXJUaW1lO1xuICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBpZiAodGhpcy5jdXJyZW50U3BlZWQgIT09IDApIHtcbiAgICAgIHRoaXMuY3VycmVudEZyYW1lICs9IGR0ICogdGhpcy5jdXJyZW50U3BlZWQ7XG4gICAgfVxuICAgIHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV90aW1lLCB0aGlzLmN1cnJlbnRGcmFtZSAqIDFlLTMpO1xuICAgIGlmICh0aGlzLnJlc29sdXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0yZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV9yZXNvbHV0aW9uLCB0aGlzLmdsLmNhbnZhcy53aWR0aCwgdGhpcy5nbC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFmKHRoaXMudW5pZm9ybUxvY2F0aW9ucy51X3BpeGVsUmF0aW8sIHRoaXMucmVuZGVyU2NhbGUpO1xuICAgICAgdGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5UUklBTkdMRVMsIDAsIDYpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRTcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmVxdWVzdFJlbmRlciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgfVxuICAgIHRoaXMucmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIpO1xuICB9O1xuICAvKiogQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSBhbiBpbWFnZSBhbmQgc2V0cyBpdCBpbnRvIGEgdW5pZm9ybSB2YWx1ZSAqL1xuICBzZXRUZXh0dXJlVW5pZm9ybSA9ICh1bmlmb3JtTmFtZSwgaW1hZ2UpID0+IHtcbiAgICBpZiAoIWltYWdlLmNvbXBsZXRlIHx8IGltYWdlLm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXBlciBTaGFkZXJzOiBpbWFnZSBmb3IgdW5pZm9ybSAke3VuaWZvcm1OYW1lfSBtdXN0IGJlIGZ1bGx5IGxvYWRlZGApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RleHR1cmUgPSB0aGlzLnRleHR1cmVzLmdldCh1bmlmb3JtTmFtZSk7XG4gICAgaWYgKGV4aXN0aW5nVGV4dHVyZSkge1xuICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKGV4aXN0aW5nVGV4dHVyZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy50ZXh0dXJlVW5pdE1hcC5oYXModW5pZm9ybU5hbWUpKSB7XG4gICAgICB0aGlzLnRleHR1cmVVbml0TWFwLnNldCh1bmlmb3JtTmFtZSwgdGhpcy50ZXh0dXJlVW5pdE1hcC5zaXplKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZVVuaXQgPSB0aGlzLnRleHR1cmVVbml0TWFwLmdldCh1bmlmb3JtTmFtZSk7XG4gICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuZ2wuTElORUFSKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcbiAgICBpZiAodW5pZm9ybU5hbWUgIT09IFwidV9ub2lzZVRleHR1cmVcIikge1xuICAgICAgdGhpcy5nbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLmdsLlRFWFRVUkVfMkQpO1xuICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IHRoaXMuZ2wuZ2V0RXJyb3IoKTtcbiAgICBpZiAoZXJyb3IgIT09IHRoaXMuZ2wuTk9fRVJST1IgfHwgdGV4dHVyZSA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlBhcGVyIFNoYWRlcnM6IFdlYkdMIGVycm9yIHdoZW4gdXBsb2FkaW5nIHRleHR1cmU6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlcy5zZXQodW5pZm9ybU5hbWUsIHRleHR1cmUpO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW3VuaWZvcm1OYW1lXTtcbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lID0gYCR7dW5pZm9ybU5hbWV9QXNwZWN0UmF0aW9gO1xuICAgICAgY29uc3QgYXNwZWN0UmF0aW9Mb2NhdGlvbiA9IHRoaXMudW5pZm9ybUxvY2F0aW9uc1thc3BlY3RSYXRpb1VuaWZvcm1OYW1lXTtcbiAgICAgIGlmIChhc3BlY3RSYXRpb0xvY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gaW1hZ2UubmF0dXJhbFdpZHRoIC8gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYoYXNwZWN0UmF0aW9Mb2NhdGlvbiwgYXNwZWN0UmF0aW8pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqIFV0aWxpdHk6IHJlY3Vyc2l2ZSBlcXVhbGl0eSB0ZXN0IGZvciBhbGwgdGhlIHVuaWZvcm1zICovXG4gIGFyZVVuaWZvcm1WYWx1ZXNFcXVhbCA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYS5ldmVyeSgodmFsLCBpKSA9PiB0aGlzLmFyZVVuaWZvcm1WYWx1ZXNFcXVhbCh2YWwsIGJbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKiogU2V0cyB0aGUgcHJvdmlkZWQgdW5pZm9ybSB2YWx1ZXMgaW50byB0aGUgV2ViR0wgcHJvZ3JhbSwgY2FuIGJlIGEgcGFydGlhbCBsaXN0IG9mIHVuaWZvcm1zIHRoYXQgaGF2ZSBjaGFuZ2VkICovXG4gIHNldFVuaWZvcm1WYWx1ZXMgPSAodXBkYXRlZFVuaWZvcm1zKSA9PiB7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgT2JqZWN0LmVudHJpZXModXBkYXRlZFVuaWZvcm1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGxldCBjYWNoZVZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIGNhY2hlVmFsdWUgPSBgJHt2YWx1ZS5zcmMuc2xpY2UoMCwgMjAwKX18JHt2YWx1ZS5uYXR1cmFsV2lkdGh9eCR7dmFsdWUubmF0dXJhbEhlaWdodH1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXJlVW5pZm9ybVZhbHVlc0VxdWFsKHRoaXMudW5pZm9ybUNhY2hlW2tleV0sIGNhY2hlVmFsdWUpKSByZXR1cm47XG4gICAgICB0aGlzLnVuaWZvcm1DYWNoZVtrZXldID0gY2FjaGVWYWx1ZTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW2tleV07XG4gICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5pZm9ybSBsb2NhdGlvbiBmb3IgJHtrZXl9IG5vdCBmb3VuZGApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZVVuaWZvcm0oa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGxldCBmbGF0QXJyYXkgPSBudWxsO1xuICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSBudWxsO1xuICAgICAgICBpZiAodmFsdWVbMF0gIT09IHZvaWQgMCAmJiBBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGRMZW5ndGggPSB2YWx1ZVswXS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHZhbHVlLmV2ZXJ5KChhcnIpID0+IGFyci5sZW5ndGggPT09IGZpcnN0Q2hpbGRMZW5ndGgpKSB7XG4gICAgICAgICAgICBmbGF0QXJyYXkgPSB2YWx1ZS5mbGF0KCk7XG4gICAgICAgICAgICB2YWx1ZUxlbmd0aCA9IGZpcnN0Q2hpbGRMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQWxsIGNoaWxkIGFycmF5cyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCBmb3IgJHtrZXl9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXRBcnJheSA9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlTGVuZ3RoID0gZmxhdEFycmF5Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHZhbHVlTGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5zdXBwb3J0ZWQgdW5pZm9ybSBhcnJheSBsZW5ndGg6ICR7dmFsdWVMZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlID8gMSA6IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGUgZm9yICR7a2V5fTogJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKiBHZXRzIHRoZSBjdXJyZW50IHRvdGFsIGFuaW1hdGlvbiB0aW1lIGZyb20gMG1zICovXG4gIGdldEN1cnJlbnRGcmFtZSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50RnJhbWU7XG4gIH07XG4gIC8qKiBTZXQgYSBmcmFtZSB0byBnZXQgYSBkZXRlcm1pbmlzdGljIHJlc3VsdCwgZnJhbWVzIGFyZSBsaXRlcmFsbHkganVzdCBtaWxsaXNlY29uZHMgZnJvbSB6ZXJvIHNpbmNlIHRoZSBhbmltYXRpb24gc3RhcnRlZCAqL1xuICBzZXRGcmFtZSA9IChuZXdGcmFtZSkgPT4ge1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gbmV3RnJhbWU7XG4gICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgfTtcbiAgLyoqIFNldCBhbiBhbmltYXRpb24gc3BlZWQgKG9yIDAgdG8gc3RvcCBhbmltYXRpb24pICovXG4gIHNldFNwZWVkID0gKG5ld1NwZWVkID0gMSkgPT4ge1xuICAgIHRoaXMuc3BlZWQgPSBuZXdTcGVlZDtcbiAgICB0aGlzLnNldEN1cnJlbnRTcGVlZChkb2N1bWVudC5oaWRkZW4gPyAwIDogbmV3U3BlZWQpO1xuICB9O1xuICBzZXRDdXJyZW50U3BlZWQgPSAobmV3U3BlZWQpID0+IHtcbiAgICB0aGlzLmN1cnJlbnRTcGVlZCA9IG5ld1NwZWVkO1xuICAgIGlmICh0aGlzLnJhZklkID09PSBudWxsICYmIG5ld1NwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmFmSWQgIT09IG51bGwgJiYgbmV3U3BlZWQgPT09IDApIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKiogU2V0IHRoZSBtYXhpbXVtIHBpeGVsIGNvdW50IGZvciB0aGUgc2hhZGVyLCB0aGlzIHdpbGwgbGltaXQgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB3aWxsIGJlIHJlbmRlcmVkICovXG4gIHNldE1heFBpeGVsQ291bnQgPSAobmV3TWF4UGl4ZWxDb3VudCA9IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UKSA9PiB7XG4gICAgdGhpcy5tYXhQaXhlbENvdW50ID0gbmV3TWF4UGl4ZWxDb3VudDtcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICB9O1xuICAvKiogU2V0IHRoZSBtaW5pbXVtIHBpeGVsIHJhdGlvIGZvciB0aGUgc2hhZGVyICovXG4gIHNldE1pblBpeGVsUmF0aW8gPSAobmV3TWluUGl4ZWxSYXRpbyA9IDIpID0+IHtcbiAgICB0aGlzLm1pblBpeGVsUmF0aW8gPSBuZXdNaW5QaXhlbFJhdGlvO1xuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gIH07XG4gIC8qKiBVcGRhdGUgdGhlIHVuaWZvcm1zIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSBvdXRzaWRlIHNoYWRlciwgY2FuIGJlIGEgcGFydGlhbCBzZXQgd2l0aCBvbmx5IHRoZSB1bmlmb3JtcyB0aGF0IGhhdmUgY2hhbmdlZCAqL1xuICBzZXRVbmlmb3JtcyA9IChuZXdVbmlmb3JtcykgPT4ge1xuICAgIHRoaXMuc2V0VW5pZm9ybVZhbHVlcyhuZXdVbmlmb3Jtcyk7XG4gICAgdGhpcy5wcm92aWRlZFVuaWZvcm1zID0geyAuLi50aGlzLnByb3ZpZGVkVW5pZm9ybXMsIC4uLm5ld1VuaWZvcm1zIH07XG4gICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICB9O1xuICBoYW5kbGVEb2N1bWVudFZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRDdXJyZW50U3BlZWQoZG9jdW1lbnQuaGlkZGVuID8gMCA6IHRoaXMuc3BlZWQpO1xuICB9O1xuICAvKiogRGlzcG9zZSBvZiB0aGUgc2hhZGVyIG1vdW50LCBjbGVhbmluZyB1cCBhbGwgb2YgdGhlIFdlYkdMIHJlc291cmNlcyAqL1xuICBkaXNwb3NlID0gKCkgPT4ge1xuICAgIHRoaXMuaGFzQmVlbkRpc3Bvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgICB0aGlzLnJhZklkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2wgJiYgdGhpcy5wcm9ncmFtKSB7XG4gICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2goKHRleHR1cmUpID0+IHtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRleHR1cmVzLmNsZWFyKCk7XG4gICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gICAgdmlzdWFsVmlld3BvcnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5oYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdGhpcy5oYW5kbGVEb2N1bWVudFZpc2liaWxpdHlDaGFuZ2UpO1xuICAgIHRoaXMudW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAgIHRoaXMuY2FudmFzRWxlbWVudC5yZW1vdmUoKTtcbiAgICBkZWxldGUgdGhpcy5wYXJlbnRFbGVtZW50LnBhcGVyU2hhZGVyTW91bnQ7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFkZXIoZ2wsIHR5cGUsIHNvdXJjZSkge1xuICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gIGlmICghc2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCBjb21waWxpbmcgdGhlIHNoYWRlcnM6IFwiICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gc2hhZGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyU291cmNlMiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgY29uc3QgZm9ybWF0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKTtcbiAgY29uc3QgcHJlY2lzaW9uID0gZm9ybWF0ID8gZm9ybWF0LnByZWNpc2lvbiA6IG51bGw7XG4gIGlmIChwcmVjaXNpb24gJiYgcHJlY2lzaW9uIDwgMjMpIHtcbiAgICB2ZXJ0ZXhTaGFkZXJTb3VyY2UyID0gdmVydGV4U2hhZGVyU291cmNlMi5yZXBsYWNlKC9wcmVjaXNpb25cXHMrKGxvd3B8bWVkaXVtcClcXHMrZmxvYXQ7L2csIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1wiKTtcbiAgICBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGZyYWdtZW50U2hhZGVyU291cmNlLnJlcGxhY2UoL3ByZWNpc2lvblxccysobG93cHxtZWRpdW1wKVxccytmbG9hdC9nLCBcInByZWNpc2lvbiBoaWdocCBmbG9hdFwiKS5yZXBsYWNlKC9cXGIodW5pZm9ybXx2YXJ5aW5nfGF0dHJpYnV0ZSlcXHMrKGxvd3B8bWVkaXVtcClcXHMrKFxcdyspL2csIFwiJDEgaGlnaHAgJDNcIik7XG4gIH1cbiAgY29uc3QgdmVydGV4U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UyKTtcbiAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICBpZiAoIXZlcnRleFNoYWRlciB8fCAhZnJhZ21lbnRTaGFkZXIpIHJldHVybiBudWxsO1xuICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBpZiAoIXByb2dyYW0pIHJldHVybiBudWxsO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluaXRpYWxpemUgdGhlIHNoYWRlciBwcm9ncmFtOiBcIiArIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmRldGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICByZXR1cm4gcHJvZ3JhbTtcbn1cbmNvbnN0IGRlZmF1bHRTdHlsZSA9IGBAbGF5ZXIgcGFwZXItc2hhZGVycyB7XG4gIDp3aGVyZShbZGF0YS1wYXBlci1zaGFkZXJdKSB7XG4gICAgaXNvbGF0aW9uOiBpc29sYXRlO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICYgY2FudmFzIHtcbiAgICAgIGNvbnRhaW46IHN0cmljdDtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgaW5zZXQ6IDA7XG4gICAgICB6LWluZGV4OiAtMTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcbiAgICAgIGNvcm5lci1zaGFwZTogaW5oZXJpdDtcbiAgICB9XG4gIH1cbn1gO1xuZnVuY3Rpb24gaXNQYXBlclNoYWRlckVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gXCJwYXBlclNoYWRlck1vdW50XCIgaW4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHVhLmluY2x1ZGVzKFwic2FmYXJpXCIpICYmICF1YS5pbmNsdWRlcyhcImNocm9tZVwiKSAmJiAhdWEuaW5jbHVkZXMoXCJhbmRyb2lkXCIpO1xufVxuZnVuY3Rpb24gYmVzdEd1ZXNzQnJvd3Nlclpvb20oKSB7XG4gIGNvbnN0IHZpZXdwb3J0U2NhbGUgPSB2aXN1YWxWaWV3cG9ydD8uc2NhbGUgPz8gMTtcbiAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IHZpc3VhbFZpZXdwb3J0Py53aWR0aCA/PyB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgY29uc3QgaW5uZXJXaWR0aCA9IHZpZXdwb3J0U2NhbGUgKiB2aWV3cG9ydFdpZHRoICsgc2Nyb2xsYmFyV2lkdGg7XG4gIGNvbnN0IHJhdGlvID0gb3V0ZXJXaWR0aCAvIGlubmVyV2lkdGg7XG4gIGNvbnN0IHpvb21QZXJjZW50YWdlUm91bmRlZCA9IE1hdGgucm91bmQoMTAwICogcmF0aW8pO1xuICBpZiAoem9vbVBlcmNlbnRhZ2VSb3VuZGVkICUgNSA9PT0gMCkge1xuICAgIHJldHVybiB6b29tUGVyY2VudGFnZVJvdW5kZWQgLyAxMDA7XG4gIH1cbiAgaWYgKHpvb21QZXJjZW50YWdlUm91bmRlZCA9PT0gMzMpIHtcbiAgICByZXR1cm4gMSAvIDM7XG4gIH1cbiAgaWYgKHpvb21QZXJjZW50YWdlUm91bmRlZCA9PT0gNjcpIHtcbiAgICByZXR1cm4gMiAvIDM7XG4gIH1cbiAgaWYgKHpvb21QZXJjZW50YWdlUm91bmRlZCA9PT0gMTMzKSB7XG4gICAgcmV0dXJuIDQgLyAzO1xuICB9XG4gIHJldHVybiByYXRpbztcbn1cbmV4cG9ydCB7XG4gIFNoYWRlck1vdW50LFxuICBpc1BhcGVyU2hhZGVyRWxlbWVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci1tb3VudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-sizing.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderFitOptions: () => (/* binding */ ShaderFitOptions),\n/* harmony export */   defaultObjectSizing: () => (/* binding */ defaultObjectSizing),\n/* harmony export */   defaultPatternSizing: () => (/* binding */ defaultPatternSizing),\n/* harmony export */   drawSizingHelpers: () => (/* binding */ drawSizingHelpers),\n/* harmony export */   sizingDebugVariablesDeclaration: () => (/* binding */ sizingDebugVariablesDeclaration),\n/* harmony export */   sizingUV: () => (/* binding */ sizingUV),\n/* harmony export */   sizingUniformsDeclaration: () => (/* binding */ sizingUniformsDeclaration),\n/* harmony export */   sizingVariablesDeclaration: () => (/* binding */ sizingVariablesDeclaration)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;\nin vec2 v_imageUV;`;\nconst sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\nconst sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\nconst sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(u_resolution.x / fixedRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(u_resolution.x / fixedRatio, u_resolution.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(u_resolution.x / patternBoxRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(u_resolution.x / patternBoxRatio, u_resolution.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n    \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for image filters\n  \n  #ifdef USE_IMAGE_SIZING\n\n    vec2 imageBoxSize;\n    if (u_fit == 1.) { // contain\n      imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else if (u_fit == 2.) { // cover\n      imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else {\n      imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n    }\n    imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n    vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n    #ifdef ADD_HELPERS\n      vec2 imageHelperBox = uv;\n      imageHelperBox *= imageBoxScale;\n      imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n    #endif\n\n    vec2 imageUV = uv;\n    imageUV *= imageBoxScale;\n    imageUV += boxOrigin * (imageBoxScale - 1.);\n    imageUV += graphicOffset;\n    imageUV /= u_scale;\n    imageUV.x *= u_imageAspectRatio;\n    imageUV = graphicRotation * imageUV;\n    imageUV.x /= u_imageAspectRatio;\n    \n    imageUV += .5;\n    imageUV.y = 1. - imageUV.y;\n  #endif\n`;\nconst drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\nconst defaultObjectSizing = {\n  fit: \"contain\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst defaultPatternSizing = {\n  fit: \"none\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2\n};\n\n//# sourceMappingURL=shader-sizing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXItc2l6aW5nLmpzPzI5Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IHNpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9uID0gYFxuaW4gdmVjMiB2X29iamVjdFVWO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVVVjtcbmluIHZlYzIgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplO1xuaW4gdmVjMiB2X3BhdHRlcm5VVjtcbmluIHZlYzIgdl9pbWFnZVVWO2A7XG5jb25zdCBzaXppbmdEZWJ1Z1ZhcmlhYmxlc0RlY2xhcmF0aW9uID0gYFxuaW4gdmVjMiB2X29iamVjdEJveFNpemU7XG5pbiB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVCb3hTaXplO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5pbiB2ZWMyIHZfcGF0dGVybkJveFNpemU7XG5pbiB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtgO1xuY29uc3Qgc2l6aW5nVW5pZm9ybXNEZWNsYXJhdGlvbiA9IGBcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5YO1xudW5pZm9ybSBmbG9hdCB1X29yaWdpblk7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRXaWR0aDtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZEhlaWdodDtcbnVuaWZvcm0gZmxvYXQgdV9maXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcbnVuaWZvcm0gZmxvYXQgdV9yb3RhdGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRYO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFk7YDtcbmNvbnN0IHNpemluZ1VWID0gYFxuXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICNpZmRlZiBVU0VfUElYRUxJWkFUSU9OXG4gICAgZmxvYXQgcHhTaXplID0gdV9weFNpemUgKiB1X3BpeGVsUmF0aW87XG4gICAgdmVjMiBweFNpemVVdiA9IGdsX0ZyYWdDb29yZC54eTtcbiAgICBweFNpemVVdiAtPSAuNSAqIHVfcmVzb2x1dGlvbjtcbiAgICBweFNpemVVdiAvPSBweFNpemU7XG4gICAgdXYgPSBmbG9vcihweFNpemVVdikgKiBweFNpemUgLyB1X3Jlc29sdXRpb24ueHk7ICAgIFxuICAgIHV2ICs9IC41O1xuICAjZW5kaWZcbiAgdXYgLT0gLjU7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBzaXppbmcgcGFyYW1zIHNoYXJlZCBiZXR3ZWVuIG9iamVjdHMgYW5kIHBhdHRlcm5zXG4gIFxuICB2ZWMyIGJveE9yaWdpbiA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBnaXZlbkJveFNpemUgPSB2ZWMyKHVfd29ybGRXaWR0aCwgdV93b3JsZEhlaWdodCk7XG4gIGdpdmVuQm94U2l6ZSA9IG1heChnaXZlbkJveFNpemUsIHZlYzIoMS4pKSAqIHVfcGl4ZWxSYXRpbztcbiAgZmxvYXQgciA9IHVfcm90YXRpb24gKiAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2IC8gMTgwLjtcbiAgbWF0MiBncmFwaGljUm90YXRpb24gPSBtYXQyKGNvcyhyKSwgc2luKHIpLCAtc2luKHIpLCBjb3MocikpO1xuICB2ZWMyIGdyYXBoaWNPZmZzZXQgPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBvYmplY3RzIChncmFwaGljcyB3aXRoIGZpeGVkIHJhdGlvKVxuXG4gICNpZmRlZiBVU0VfT0JKRUNUX1NJWklOR1xuICAgIGZsb2F0IGZpeGVkUmF0aW8gPSAxLjtcbiAgICB2ZWMyIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBvYmplY3RCb3hTaXplID0gdmVjMigwLik7XG4gICAgLy8gZml0ID0gbm9uZVxuICAgIG9iamVjdEJveFNpemUueCA9IGZpeGVkUmF0aW8gKiBtaW4oZml4ZWRSYXRpb0JveEdpdmVuU2l6ZS54IC8gZml4ZWRSYXRpbywgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZS55KTtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1pbih1X3Jlc29sdXRpb24ueCAvIGZpeGVkUmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7ICAvLyBmaXQgPSBjb3ZlclxuICAgICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIGZpeGVkUmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9XG4gICAgb2JqZWN0Qm94U2l6ZS55ID0gb2JqZWN0Qm94U2l6ZS54IC8gZml4ZWRSYXRpbztcbiAgICB2ZWMyIG9iamVjdFdvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBvYmplY3RCb3hTaXplO1xuICBcbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgb2JqZWN0SGVscGVyQm94ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAgICAgb2JqZWN0SGVscGVyQm94IC09IC41O1xuICAgICAgb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgICBvYmplY3RIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7ICBcbiAgICAjZW5kaWZcbiAgXG4gICAgdmVjMiBvYmplY3RVViA9IHV2O1xuICAgIG9iamVjdFVWICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgb2JqZWN0VVYgKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gICAgb2JqZWN0VVYgKz0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuICAgIG9iamVjdFVWIC89IHVfc2NhbGU7XG4gICAgb2JqZWN0VVYgPSBncmFwaGljUm90YXRpb24gKiBvYmplY3RVVjtcbiAgI2VuZGlmXG4gIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIHBhdHRlcm5zIChncmFwaGljcyByZXNwZWN0aW5nIHVfd29ybGRXaWR0aCAvIHVfd29ybGRIZWlnaHQgcmF0aW8pXG4gIFxuICAjaWZkZWYgVVNFX1BBVFRFUk5fU0laSU5HXG4gICAgZmxvYXQgcGF0dGVybkJveFJhdGlvID0gZ2l2ZW5Cb3hTaXplLnggLyBnaXZlbkJveFNpemUueTtcbiAgICB2ZWMyIHBhdHRlcm5Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBwYXR0ZXJuQm94U2l6ZSA9IHZlYzIoMC4pO1xuICAgIC8vIGZpdCA9IG5vbmVcbiAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWluKHBhdHRlcm5Cb3hHaXZlblNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbywgcGF0dGVybkJveEdpdmVuU2l6ZS55KTtcbiAgICBmbG9hdCBwYXR0ZXJuV29ybGROb0ZpdEJveFdpZHRoID0gcGF0dGVybkJveFNpemUueDtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgIC8vIGZpdCA9IGNvbnRhaW5cbiAgICAgIHBhdHRlcm5Cb3hTaXplLnggPSBwYXR0ZXJuQm94UmF0aW8gKiBtaW4odV9yZXNvbHV0aW9uLnggLyBwYXR0ZXJuQm94UmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7ICAvLyBmaXQgPSBjb3ZlclxuICAgICAgcGF0dGVybkJveFNpemUueCA9IHBhdHRlcm5Cb3hSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIHBhdHRlcm5Cb3hSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICAgIH1cbiAgICBwYXR0ZXJuQm94U2l6ZS55ID0gcGF0dGVybkJveFNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbztcbiAgICB2ZWMyIHBhdHRlcm5Xb3JsZFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gcGF0dGVybkJveFNpemU7XG4gIFxuICAgICNpZmRlZiBBRERfSEVMUEVSUyAgXG4gICAgICB2ZWMyIHBhdHRlcm5IZWxwZXJCb3ggPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICAgICBwYXR0ZXJuSGVscGVyQm94IC09IC41O1xuICAgICAgcGF0dGVybkhlbHBlckJveCAqPSBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICAgIHBhdHRlcm5IZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHBhdHRlcm5Xb3JsZFNjYWxlIC0gMS4pOyAgXG4gICAgI2VuZGlmXG4gIFxuICAgIHZlYzIgcGF0dGVyblVWID0gdXY7XG4gICAgcGF0dGVyblVWICs9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKSAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViArPSBib3hPcmlnaW47XG4gICAgcGF0dGVyblVWIC09IGJveE9yaWdpbiAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViAqPSB1X3Jlc29sdXRpb24ueHk7XG4gICAgcGF0dGVyblVWIC89IHVfcGl4ZWxSYXRpbztcbiAgICBpZiAodV9maXQgPiAwLikge1xuICAgICAgcGF0dGVyblVWICo9IChwYXR0ZXJuV29ybGROb0ZpdEJveFdpZHRoIC8gcGF0dGVybkJveFNpemUueCk7XG4gICAgfVxuICAgIHBhdHRlcm5VViAvPSB1X3NjYWxlO1xuICAgIHBhdHRlcm5VViA9IGdyYXBoaWNSb3RhdGlvbiAqIHBhdHRlcm5VVjtcbiAgICBwYXR0ZXJuVVYgKz0gYm94T3JpZ2luIC8gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgcGF0dGVyblVWIC09IGJveE9yaWdpbjtcbiAgICBwYXR0ZXJuVVYgKz0gLjU7XG4gICNlbmRpZlxuICAgIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGltYWdlIGZpbHRlcnNcbiAgXG4gICNpZmRlZiBVU0VfSU1BR0VfU0laSU5HXG5cbiAgICB2ZWMyIGltYWdlQm94U2l6ZTtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgLy8gY29udGFpblxuICAgICAgaW1hZ2VCb3hTaXplLnggPSBtaW4odV9yZXNvbHV0aW9uLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIHVfcmVzb2x1dGlvbi55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7IC8vIGNvdmVyXG4gICAgICBpbWFnZUJveFNpemUueCA9IG1heCh1X3Jlc29sdXRpb24ueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbywgdV9yZXNvbHV0aW9uLnkpICogdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZUJveFNpemUueCA9IG1pbigxMC4wLCAxMC4wIC8gdV9pbWFnZUFzcGVjdFJhdGlvICogdV9pbWFnZUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgaW1hZ2VCb3hTaXplLnkgPSBpbWFnZUJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB2ZWMyIGltYWdlQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBpbWFnZUJveFNpemU7XG5cbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgaW1hZ2VIZWxwZXJCb3ggPSB1djtcbiAgICAgIGltYWdlSGVscGVyQm94ICo9IGltYWdlQm94U2NhbGU7XG4gICAgICBpbWFnZUhlbHBlckJveCArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgICAjZW5kaWZcblxuICAgIHZlYzIgaW1hZ2VVViA9IHV2O1xuICAgIGltYWdlVVYgKj0gaW1hZ2VCb3hTY2FsZTtcbiAgICBpbWFnZVVWICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICAgIGltYWdlVVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgICBpbWFnZVVWIC89IHVfc2NhbGU7XG4gICAgaW1hZ2VVVi54ICo9IHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICBpbWFnZVVWID0gZ3JhcGhpY1JvdGF0aW9uICogaW1hZ2VVVjtcbiAgICBpbWFnZVVWLnggLz0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIFxuICAgIGltYWdlVVYgKz0gLjU7XG4gICAgaW1hZ2VVVi55ID0gMS4gLSBpbWFnZVVWLnk7XG4gICNlbmRpZlxuYDtcbmNvbnN0IGRyYXdTaXppbmdIZWxwZXJzID0gYFxuICB2ZWMyIHdvcmxkQm94RGlzdCA9IGFicyhoZWxwZXJCb3gpO1xuICBmbG9hdCBib3hTdHJva2UgPSAoc3RlcChtYXgod29ybGRCb3hEaXN0LngsIHdvcmxkQm94RGlzdC55KSwgLjUpIC0gc3RlcChtYXgod29ybGRCb3hEaXN0LngsIHdvcmxkQm94RGlzdC55KSwgLjQ5NSkpO1xuICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB2ZWMzKDEuLCAwLiwgMC4pLCBib3hTdHJva2UpO1xuICBvcGFjaXR5ICs9IGJveFN0cm9rZTtcblxuICB2ZWMyIGJveE9yaWdpbkNvcHkgPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgYm94T3JpZ2luRGlzdCA9IGhlbHBlckJveCArIGJveE9yaWdpbkNvcHk7XG4gIGJveE9yaWdpbkRpc3QueCAqPSAoYm94U2l6ZS54IC8gYm94U2l6ZS55KTtcbiAgZmxvYXQgYm94T3JpZ2luUG9pbnQgPSAxLiAtIHNtb290aHN0ZXAoMC4sIC4wNSwgbGVuZ3RoKGJveE9yaWdpbkRpc3QpKTtcbiAgXG4gIHZlYzIgZ3JhcGhpY09yaWdpblBvaW50RGlzdCA9IGhlbHBlckJveCArIHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcbiAgZ3JhcGhpY09yaWdpblBvaW50RGlzdC54ICo9IChib3hTaXplLnggLyBib3hTaXplLnkpO1xuICBmbG9hdCBncmFwaGljT3JpZ2luUG9pbnQgPSAxLiAtIHNtb290aHN0ZXAoMC4sIC4wNSwgbGVuZ3RoKGdyYXBoaWNPcmlnaW5Qb2ludERpc3QpKTtcbiAgXG4gIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHZlYzMoMC4sIDEuLCAwLiksIGJveE9yaWdpblBvaW50KTtcbiAgb3BhY2l0eSArPSBib3hPcmlnaW5Qb2ludDtcbiAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdmVjMygwLiwgMC4sIDEuKSwgZ3JhcGhpY09yaWdpblBvaW50KTtcbiAgb3BhY2l0eSArPSBncmFwaGljT3JpZ2luUG9pbnQ7XG5gO1xuY29uc3QgZGVmYXVsdE9iamVjdFNpemluZyA9IHtcbiAgZml0OiBcImNvbnRhaW5cIixcbiAgc2NhbGU6IDEsXG4gIHJvdGF0aW9uOiAwLFxuICBvZmZzZXRYOiAwLFxuICBvZmZzZXRZOiAwLFxuICBvcmlnaW5YOiAwLjUsXG4gIG9yaWdpblk6IDAuNSxcbiAgd29ybGRXaWR0aDogMCxcbiAgd29ybGRIZWlnaHQ6IDBcbn07XG5jb25zdCBkZWZhdWx0UGF0dGVyblNpemluZyA9IHtcbiAgZml0OiBcIm5vbmVcIixcbiAgc2NhbGU6IDEsXG4gIHJvdGF0aW9uOiAwLFxuICBvZmZzZXRYOiAwLFxuICBvZmZzZXRZOiAwLFxuICBvcmlnaW5YOiAwLjUsXG4gIG9yaWdpblk6IDAuNSxcbiAgd29ybGRXaWR0aDogMCxcbiAgd29ybGRIZWlnaHQ6IDBcbn07XG5jb25zdCBTaGFkZXJGaXRPcHRpb25zID0ge1xuICBub25lOiAwLFxuICBjb250YWluOiAxLFxuICBjb3ZlcjogMlxufTtcbmV4cG9ydCB7XG4gIFNoYWRlckZpdE9wdGlvbnMsXG4gIGRlZmF1bHRPYmplY3RTaXppbmcsXG4gIGRlZmF1bHRQYXR0ZXJuU2l6aW5nLFxuICBkcmF3U2l6aW5nSGVscGVycyxcbiAgc2l6aW5nRGVidWdWYXJpYWJsZXNEZWNsYXJhdGlvbixcbiAgc2l6aW5nVVYsXG4gIHNpemluZ1VuaWZvcm1zRGVjbGFyYXRpb24sXG4gIHNpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyLXNpemluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorBandingFix: () => (/* binding */ colorBandingFix),\n/* harmony export */   declarePI: () => (/* binding */ declarePI),\n/* harmony export */   fiberNoise: () => (/* binding */ fiberNoise),\n/* harmony export */   proceduralHash11: () => (/* binding */ proceduralHash11),\n/* harmony export */   proceduralHash21: () => (/* binding */ proceduralHash21),\n/* harmony export */   proceduralHash22: () => (/* binding */ proceduralHash22),\n/* harmony export */   rotation2: () => (/* binding */ rotation2),\n/* harmony export */   simplexNoise: () => (/* binding */ simplexNoise),\n/* harmony export */   textureRandomizerGB: () => (/* binding */ textureRandomizerGB),\n/* harmony export */   textureRandomizerR: () => (/* binding */ textureRandomizerR)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\nconst rotation2 = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\nconst proceduralHash11 = `\n  float hash11(float p) {\n    p = fract(p * 0.3183099) + 0.1;\n    p *= p + 19.19;\n    return fract(p * p);\n  }\n`;\nconst proceduralHash21 = `\n  float hash21(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p + 19.19);\n    return fract(p.x * p.y);\n  }\n`;\nconst proceduralHash22 = `\n  vec2 hash22(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p.yx + 19.19);\n    return fract(vec2(p.x * p.y, p.x + p.y));\n  }\n`;\nconst textureRandomizerR = `\n  float randomR(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).r;\n  }\n`;\nconst textureRandomizerGB = `\n  vec2 randomGB(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).gb;\n  }\n`;\nconst colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\nconst simplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\nconst fiberNoise = `\nfloat fiberRandom(vec2 p) {\n  vec2 uv = floor(p) / 100.;\n  return texture(u_noiseTexture, fract(uv)).b;\n}\n\nfloat fiberValueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = fiberRandom(i);\n  float b = fiberRandom(i + vec2(1.0, 0.0));\n  float c = fiberRandom(i + vec2(0.0, 1.0));\n  float d = fiberRandom(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat fiberNoiseFbm(in vec2 n, vec2 seedOffset) {\n  float total = 0.0, amplitude = 1.;\n  for (int i = 0; i < 4; i++) {\n    n = rotate(n, .7);\n    total += fiberValueNoise(n + seedOffset) * amplitude;\n    n *= 2.;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\nfloat fiberNoise(vec2 uv, vec2 seedOffset) {\n  float epsilon = 0.001;\n  float n1 = fiberNoiseFbm(uv + vec2(epsilon, 0.0), seedOffset);\n  float n2 = fiberNoiseFbm(uv - vec2(epsilon, 0.0), seedOffset);\n  float n3 = fiberNoiseFbm(uv + vec2(0.0, epsilon), seedOffset);\n  float n4 = fiberNoiseFbm(uv - vec2(0.0, epsilon), seedOffset);\n  return length(vec2(n1 - n2, n3 - n4)) / (2.0 * epsilon);\n}\n`;\n\n//# sourceMappingURL=shader-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzPzRiMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IGRlY2xhcmVQSSA9IGBcbiNkZWZpbmUgVFdPX1BJIDYuMjgzMTg1MzA3MThcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NlxuYDtcbmNvbnN0IHJvdGF0aW9uMiA9IGBcbnZlYzIgcm90YXRlKHZlYzIgdXYsIGZsb2F0IHRoKSB7XG4gIHJldHVybiBtYXQyKGNvcyh0aCksIHNpbih0aCksIC1zaW4odGgpLCBjb3ModGgpKSAqIHV2O1xufVxuYDtcbmNvbnN0IHByb2NlZHVyYWxIYXNoMTEgPSBgXG4gIGZsb2F0IGhhc2gxMShmbG9hdCBwKSB7XG4gICAgcCA9IGZyYWN0KHAgKiAwLjMxODMwOTkpICsgMC4xO1xuICAgIHAgKj0gcCArIDE5LjE5O1xuICAgIHJldHVybiBmcmFjdChwICogcCk7XG4gIH1cbmA7XG5jb25zdCBwcm9jZWR1cmFsSGFzaDIxID0gYFxuICBmbG9hdCBoYXNoMjEodmVjMiBwKSB7XG4gICAgcCA9IGZyYWN0KHAgKiB2ZWMyKDAuMzE4MzA5OSwgMC4zNjc4Nzk0KSkgKyAwLjE7XG4gICAgcCArPSBkb3QocCwgcCArIDE5LjE5KTtcbiAgICByZXR1cm4gZnJhY3QocC54ICogcC55KTtcbiAgfVxuYDtcbmNvbnN0IHByb2NlZHVyYWxIYXNoMjIgPSBgXG4gIHZlYzIgaGFzaDIyKHZlYzIgcCkge1xuICAgIHAgPSBmcmFjdChwICogdmVjMigwLjMxODMwOTksIDAuMzY3ODc5NCkpICsgMC4xO1xuICAgIHAgKz0gZG90KHAsIHAueXggKyAxOS4xOSk7XG4gICAgcmV0dXJuIGZyYWN0KHZlYzIocC54ICogcC55LCBwLnggKyBwLnkpKTtcbiAgfVxuYDtcbmNvbnN0IHRleHR1cmVSYW5kb21pemVyUiA9IGBcbiAgZmxvYXQgcmFuZG9tUih2ZWMyIHApIHtcbiAgICB2ZWMyIHV2ID0gZmxvb3IocCkgLyAxMDAuICsgLjU7XG4gICAgcmV0dXJuIHRleHR1cmUodV9ub2lzZVRleHR1cmUsIGZyYWN0KHV2KSkucjtcbiAgfVxuYDtcbmNvbnN0IHRleHR1cmVSYW5kb21pemVyR0IgPSBgXG4gIHZlYzIgcmFuZG9tR0IodmVjMiBwKSB7XG4gICAgdmVjMiB1diA9IGZsb29yKHApIC8gMTAwLiArIC41O1xuICAgIHJldHVybiB0ZXh0dXJlKHVfbm9pc2VUZXh0dXJlLCBmcmFjdCh1dikpLmdiO1xuICB9XG5gO1xuY29uc3QgY29sb3JCYW5kaW5nRml4ID0gYFxuICBjb2xvciArPSAxLiAvIDI1Ni4gKiAoZnJhY3Qoc2luKGRvdCguMDE0ICogZ2xfRnJhZ0Nvb3JkLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpIC0gLjUpO1xuYDtcbmNvbnN0IHNpbXBsZXhOb2lzZSA9IGBcbnZlYzMgcGVybXV0ZSh2ZWMzIHgpIHsgcmV0dXJuIG1vZCgoKHggKiAzNC4wKSArIDEuMCkgKiB4LCAyODkuMCk7IH1cbmZsb2F0IHNub2lzZSh2ZWMyIHYpIHtcbiAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NywgMC4zNjYwMjU0MDM3ODQ0MzksXG4gICAgLTAuNTc3MzUwMjY5MTg5NjI2LCAwLjAyNDM5MDI0MzkwMjQzOSk7XG4gIHZlYzIgaSA9IGZsb29yKHYgKyBkb3QodiwgQy55eSkpO1xuICB2ZWMyIHgwID0gdiAtIGkgKyBkb3QoaSwgQy54eCk7XG4gIHZlYzIgaTE7XG4gIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XG4gIHZlYzQgeDEyID0geDAueHl4eSArIEMueHh6ejtcbiAgeDEyLnh5IC09IGkxO1xuICBpID0gbW9kKGksIDI4OS4wKTtcbiAgdmVjMyBwID0gcGVybXV0ZShwZXJtdXRlKGkueSArIHZlYzMoMC4wLCBpMS55LCAxLjApKVxuICAgICsgaS54ICsgdmVjMygwLjAsIGkxLngsIDEuMCkpO1xuICB2ZWMzIG0gPSBtYXgoMC41IC0gdmVjMyhkb3QoeDAsIHgwKSwgZG90KHgxMi54eSwgeDEyLnh5KSxcbiAgICAgIGRvdCh4MTIuencsIHgxMi56dykpLCAwLjApO1xuICBtID0gbSAqIG07XG4gIG0gPSBtICogbTtcbiAgdmVjMyB4ID0gMi4wICogZnJhY3QocCAqIEMud3d3KSAtIDEuMDtcbiAgdmVjMyBoID0gYWJzKHgpIC0gMC41O1xuICB2ZWMzIG94ID0gZmxvb3IoeCArIDAuNSk7XG4gIHZlYzMgYTAgPSB4IC0gb3g7XG4gIG0gKj0gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiAoYTAgKiBhMCArIGggKiBoKTtcbiAgdmVjMyBnO1xuICBnLnggPSBhMC54ICogeDAueCArIGgueCAqIHgwLnk7XG4gIGcueXogPSBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXc7XG4gIHJldHVybiAxMzAuMCAqIGRvdChtLCBnKTtcbn1cbmA7XG5jb25zdCBmaWJlck5vaXNlID0gYFxuZmxvYXQgZmliZXJSYW5kb20odmVjMiBwKSB7XG4gIHZlYzIgdXYgPSBmbG9vcihwKSAvIDEwMC47XG4gIHJldHVybiB0ZXh0dXJlKHVfbm9pc2VUZXh0dXJlLCBmcmFjdCh1dikpLmI7XG59XG5cbmZsb2F0IGZpYmVyVmFsdWVOb2lzZSh2ZWMyIHN0KSB7XG4gIHZlYzIgaSA9IGZsb29yKHN0KTtcbiAgdmVjMiBmID0gZnJhY3Qoc3QpO1xuICBmbG9hdCBhID0gZmliZXJSYW5kb20oaSk7XG4gIGZsb2F0IGIgPSBmaWJlclJhbmRvbShpICsgdmVjMigxLjAsIDAuMCkpO1xuICBmbG9hdCBjID0gZmliZXJSYW5kb20oaSArIHZlYzIoMC4wLCAxLjApKTtcbiAgZmxvYXQgZCA9IGZpYmVyUmFuZG9tKGkgKyB2ZWMyKDEuMCwgMS4wKSk7XG4gIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpO1xuICBmbG9hdCB4MSA9IG1peChhLCBiLCB1LngpO1xuICBmbG9hdCB4MiA9IG1peChjLCBkLCB1LngpO1xuICByZXR1cm4gbWl4KHgxLCB4MiwgdS55KTtcbn1cblxuZmxvYXQgZmliZXJOb2lzZUZibShpbiB2ZWMyIG4sIHZlYzIgc2VlZE9mZnNldCkge1xuICBmbG9hdCB0b3RhbCA9IDAuMCwgYW1wbGl0dWRlID0gMS47XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgbiA9IHJvdGF0ZShuLCAuNyk7XG4gICAgdG90YWwgKz0gZmliZXJWYWx1ZU5vaXNlKG4gKyBzZWVkT2Zmc2V0KSAqIGFtcGxpdHVkZTtcbiAgICBuICo9IDIuO1xuICAgIGFtcGxpdHVkZSAqPSAwLjY7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufVxuXG5mbG9hdCBmaWJlck5vaXNlKHZlYzIgdXYsIHZlYzIgc2VlZE9mZnNldCkge1xuICBmbG9hdCBlcHNpbG9uID0gMC4wMDE7XG4gIGZsb2F0IG4xID0gZmliZXJOb2lzZUZibSh1diArIHZlYzIoZXBzaWxvbiwgMC4wKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG4yID0gZmliZXJOb2lzZUZibSh1diAtIHZlYzIoZXBzaWxvbiwgMC4wKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG4zID0gZmliZXJOb2lzZUZibSh1diArIHZlYzIoMC4wLCBlcHNpbG9uKSwgc2VlZE9mZnNldCk7XG4gIGZsb2F0IG40ID0gZmliZXJOb2lzZUZibSh1diAtIHZlYzIoMC4wLCBlcHNpbG9uKSwgc2VlZE9mZnNldCk7XG4gIHJldHVybiBsZW5ndGgodmVjMihuMSAtIG4yLCBuMyAtIG40KSkgLyAoMi4wICogZXBzaWxvbik7XG59XG5gO1xuZXhwb3J0IHtcbiAgY29sb3JCYW5kaW5nRml4LFxuICBkZWNsYXJlUEksXG4gIGZpYmVyTm9pc2UsXG4gIHByb2NlZHVyYWxIYXNoMTEsXG4gIHByb2NlZHVyYWxIYXNoMjEsXG4gIHByb2NlZHVyYWxIYXNoMjIsXG4gIHJvdGF0aW9uMixcbiAgc2ltcGxleE5vaXNlLFxuICB0ZXh0dXJlUmFuZG9taXplckdCLFxuICB0ZXh0dXJlUmFuZG9taXplclJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItdXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shaders/dithering.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shaders/dithering.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DitheringShapes: () => (/* binding */ DitheringShapes),\n/* harmony export */   DitheringTypes: () => (/* binding */ DitheringTypes),\n/* harmony export */   ditheringFragmentShader: () => (/* binding */ ditheringFragmentShader)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst ditheringFragmentShader = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingUniformsDeclaration}\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorFront;\nuniform float u_shape;\nuniform float u_type;\nuniform float u_pxSize;\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.simplexNoise}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.proceduralHash11}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.proceduralHash21}\n\nfloat getSimplexNoise(vec2 uv, float t) {\n  float noise = .5 * snoise(uv - vec2(0., .3 * t));\n  noise += .5 * snoise(2. * uv + vec2(0., .32 * t));\n\n  return noise;\n}\n\nconst int bayer2x2[4] = int[4](0, 2, 3, 1);\nconst int bayer4x4[16] = int[16](\n  0,  8,  2, 10,\n 12,  4, 14,  6,\n  3, 11,  1,  9,\n 15,  7, 13,  5\n);\n\nconst int bayer8x8[64] = int[64](\n   0, 32,  8, 40,  2, 34, 10, 42,\n  48, 16, 56, 24, 50, 18, 58, 26,\n  12, 44,  4, 36, 14, 46,  6, 38,\n  60, 28, 52, 20, 62, 30, 54, 22,\n   3, 35, 11, 43,  1, 33,  9, 41,\n  51, 19, 59, 27, 49, 17, 57, 25,\n  15, 47,  7, 39, 13, 45,  5, 37,\n  63, 31, 55, 23, 61, 29, 53, 21\n);\n\nfloat getBayerValue(vec2 uv, int size) {\n  ivec2 pos = ivec2(mod(uv, float(size)));\n  int index = pos.y * size + pos.x;\n\n  if (size == 2) {\n    return float(bayer2x2[index]) / 4.0;\n  } else if (size == 4) {\n    return float(bayer4x4[index]) / 16.0;\n  } else if (size == 8) {\n    return float(bayer8x8[index]) / 64.0;\n  }\n  return 0.0;\n}\n\n\nvoid main() {\n  float t = .5 * u_time;\n\n  #define USE_PATTERN_SIZING\n  #define USE_OBJECT_SIZING\n  #define USE_PIXELIZATION\n  // #define ADD_HELPERS\n\n  ${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingUV}\n\n  vec2 dithering_uv = pxSizeUv;\n  vec2 ditheringNoise_uv = uv * u_resolution;\n  vec2 shape_uv = objectUV;\n  if (u_shape < 3.5) {\n    shape_uv = patternUV;\n  }\n\n  float shape = 0.;\n  if (u_shape < 1.5) {\n    // Simplex noise\n    shape_uv *= .001;\n\n    shape = 0.5 + 0.5 * getSimplexNoise(shape_uv, t);\n    shape = smoothstep(0.3, 0.9, shape);\n\n  } else if (u_shape < 2.5) {\n    // Warp\n    shape_uv *= .003;\n\n    for (float i = 1.0; i < 6.0; i++) {\n      shape_uv.x += 0.6 / i * cos(i * 2.5 * shape_uv.y + t);\n      shape_uv.y += 0.6 / i * cos(i * 1.5 * shape_uv.x + t);\n    }\n\n    shape = .15 / abs(sin(t - shape_uv.y - shape_uv.x));\n    shape = smoothstep(0.02, 1., shape);\n\n  } else if (u_shape < 3.5) {\n    // Dots\n    shape_uv *= .05;\n\n    float stripeIdx = floor(2. * shape_uv.x / TWO_PI);\n    float rand = hash11(stripeIdx * 10.);\n    rand = sign(rand - .5) * pow(.1 + abs(rand), .4);\n    shape = sin(shape_uv.x) * cos(shape_uv.y - 5. * rand * t);\n    shape = pow(abs(shape), 6.);\n\n  } else if (u_shape < 4.5) {\n    // Sine wave\n    shape_uv *= 4.;\n\n    float wave = cos(.5 * shape_uv.x - 2. * t) * sin(1.5 * shape_uv.x + t) * (.75 + .25 * cos(3. * t));\n    shape = 1. - smoothstep(-1., 1., shape_uv.y + wave);\n\n  } else if (u_shape < 5.5) {\n    // Ripple\n\n    float dist = length(shape_uv);\n    float waves = sin(pow(dist, 1.7) * 7. - 3. * t) * .5 + .5;\n    shape = waves;\n\n  } else if (u_shape < 6.5) {\n    // Swirl\n\n    float l = length(shape_uv);\n    float angle = 6. * atan(shape_uv.y, shape_uv.x) + 4. * t;\n    float twist = 1.2;\n    float offset = pow(l, -twist) + angle / TWO_PI;\n    float mid = smoothstep(0., 1., pow(l, twist));\n    shape = mix(0., fract(offset), mid);\n\n  } else {\n    // Sphere\n    shape_uv *= 2.;\n\n    float d = 1. - pow(length(shape_uv), 2.);\n    vec3 pos = vec3(shape_uv, sqrt(d));\n    vec3 lightPos = normalize(vec3(cos(1.5 * t), .8, sin(1.25 * t)));\n    shape = .5 + .5 * dot(lightPos, pos);\n    shape *= step(0., d);\n  }\n\n\n  int type = int(floor(u_type));\n  float dithering = 0.0;\n\n  switch (type) {\n    case 1: {\n      dithering = step(hash21(ditheringNoise_uv), shape);\n    } break;\n    case 2:\n      dithering = getBayerValue(dithering_uv, 2);\n      break;\n    case 3:\n      dithering = getBayerValue(dithering_uv, 4);\n      break;\n    default:\n      dithering = getBayerValue(dithering_uv, 8);\n      break;\n  }\n\n  dithering -= .5;\n  float res = step(.5, shape + dithering);\n\n  vec3 fgColor = u_colorFront.rgb * u_colorFront.a;\n  float fgOpacity = u_colorFront.a;\n  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;\n  float bgOpacity = u_colorBack.a;\n\n  vec3 color = fgColor * res;\n  float opacity = fgOpacity * res;\n\n  color += bgColor * (1. - opacity);\n  opacity += bgOpacity * (1. - opacity);\n\n  #ifdef ADD_HELPERS\n    vec2 helperBox = objectHelperBox;\n    vec2 boxSize = objectBoxSize;\n    if (u_shape < 3.5) {\n      helperBox = patternHelperBox;\n      boxSize = patternBoxSize;\n    }\n    ${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.drawSizingHelpers}\n  #endif\n\n  fragColor = vec4(color, opacity);\n}\n`;\nconst DitheringShapes = {\n  simplex: 1,\n  warp: 2,\n  dots: 3,\n  wave: 4,\n  ripple: 5,\n  swirl: 6,\n  sphere: 7\n};\nconst DitheringTypes = {\n  \"random\": 1,\n  \"2x2\": 2,\n  \"4x4\": 3,\n  \"8x8\": 4\n};\n\n//# sourceMappingURL=dithering.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9kaXRoZXJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFNNkI7QUFDb0U7QUFDakc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSx3RUFBeUI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRSwwREFBWTtBQUNkLEVBQUUsdURBQVM7QUFDWCxFQUFFLDhEQUFnQjtBQUNsQixFQUFFLDhEQUFnQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSx1REFBUTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdFQUFpQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXJzL2RpdGhlcmluZy5qcz8xYWNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQge1xuICBzaXppbmdVbmlmb3Jtc0RlY2xhcmF0aW9uLFxuICBzaXppbmdVVixcbiAgZHJhd1NpemluZ0hlbHBlcnNcbn0gZnJvbSBcIi4uL3NoYWRlci1zaXppbmcuanNcIjtcbmltcG9ydCB7IHNpbXBsZXhOb2lzZSwgZGVjbGFyZVBJLCBwcm9jZWR1cmFsSGFzaDExLCBwcm9jZWR1cmFsSGFzaDIxIH0gZnJvbSBcIi4uL3NoYWRlci11dGlscy5qc1wiO1xuY29uc3QgZGl0aGVyaW5nRnJhZ21lbnRTaGFkZXIgPSBgI3ZlcnNpb24gMzAwIGVzXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSBmbG9hdCB1X3BpeGVsUmF0aW87XG5cbiR7c2l6aW5nVW5pZm9ybXNEZWNsYXJhdGlvbn1cblxudW5pZm9ybSB2ZWM0IHVfY29sb3JCYWNrO1xudW5pZm9ybSB2ZWM0IHVfY29sb3JGcm9udDtcbnVuaWZvcm0gZmxvYXQgdV9zaGFwZTtcbnVuaWZvcm0gZmxvYXQgdV90eXBlO1xudW5pZm9ybSBmbG9hdCB1X3B4U2l6ZTtcblxub3V0IHZlYzQgZnJhZ0NvbG9yO1xuXG4ke3NpbXBsZXhOb2lzZX1cbiR7ZGVjbGFyZVBJfVxuJHtwcm9jZWR1cmFsSGFzaDExfVxuJHtwcm9jZWR1cmFsSGFzaDIxfVxuXG5mbG9hdCBnZXRTaW1wbGV4Tm9pc2UodmVjMiB1diwgZmxvYXQgdCkge1xuICBmbG9hdCBub2lzZSA9IC41ICogc25vaXNlKHV2IC0gdmVjMigwLiwgLjMgKiB0KSk7XG4gIG5vaXNlICs9IC41ICogc25vaXNlKDIuICogdXYgKyB2ZWMyKDAuLCAuMzIgKiB0KSk7XG5cbiAgcmV0dXJuIG5vaXNlO1xufVxuXG5jb25zdCBpbnQgYmF5ZXIyeDJbNF0gPSBpbnRbNF0oMCwgMiwgMywgMSk7XG5jb25zdCBpbnQgYmF5ZXI0eDRbMTZdID0gaW50WzE2XShcbiAgMCwgIDgsICAyLCAxMCxcbiAxMiwgIDQsIDE0LCAgNixcbiAgMywgMTEsICAxLCAgOSxcbiAxNSwgIDcsIDEzLCAgNVxuKTtcblxuY29uc3QgaW50IGJheWVyOHg4WzY0XSA9IGludFs2NF0oXG4gICAwLCAzMiwgIDgsIDQwLCAgMiwgMzQsIDEwLCA0MixcbiAgNDgsIDE2LCA1NiwgMjQsIDUwLCAxOCwgNTgsIDI2LFxuICAxMiwgNDQsICA0LCAzNiwgMTQsIDQ2LCAgNiwgMzgsXG4gIDYwLCAyOCwgNTIsIDIwLCA2MiwgMzAsIDU0LCAyMixcbiAgIDMsIDM1LCAxMSwgNDMsICAxLCAzMywgIDksIDQxLFxuICA1MSwgMTksIDU5LCAyNywgNDksIDE3LCA1NywgMjUsXG4gIDE1LCA0NywgIDcsIDM5LCAxMywgNDUsICA1LCAzNyxcbiAgNjMsIDMxLCA1NSwgMjMsIDYxLCAyOSwgNTMsIDIxXG4pO1xuXG5mbG9hdCBnZXRCYXllclZhbHVlKHZlYzIgdXYsIGludCBzaXplKSB7XG4gIGl2ZWMyIHBvcyA9IGl2ZWMyKG1vZCh1diwgZmxvYXQoc2l6ZSkpKTtcbiAgaW50IGluZGV4ID0gcG9zLnkgKiBzaXplICsgcG9zLng7XG5cbiAgaWYgKHNpemUgPT0gMikge1xuICAgIHJldHVybiBmbG9hdChiYXllcjJ4MltpbmRleF0pIC8gNC4wO1xuICB9IGVsc2UgaWYgKHNpemUgPT0gNCkge1xuICAgIHJldHVybiBmbG9hdChiYXllcjR4NFtpbmRleF0pIC8gMTYuMDtcbiAgfSBlbHNlIGlmIChzaXplID09IDgpIHtcbiAgICByZXR1cm4gZmxvYXQoYmF5ZXI4eDhbaW5kZXhdKSAvIDY0LjA7XG4gIH1cbiAgcmV0dXJuIDAuMDtcbn1cblxuXG52b2lkIG1haW4oKSB7XG4gIGZsb2F0IHQgPSAuNSAqIHVfdGltZTtcblxuICAjZGVmaW5lIFVTRV9QQVRURVJOX1NJWklOR1xuICAjZGVmaW5lIFVTRV9PQkpFQ1RfU0laSU5HXG4gICNkZWZpbmUgVVNFX1BJWEVMSVpBVElPTlxuICAvLyAjZGVmaW5lIEFERF9IRUxQRVJTXG5cbiAgJHtzaXppbmdVVn1cblxuICB2ZWMyIGRpdGhlcmluZ191diA9IHB4U2l6ZVV2O1xuICB2ZWMyIGRpdGhlcmluZ05vaXNlX3V2ID0gdXYgKiB1X3Jlc29sdXRpb247XG4gIHZlYzIgc2hhcGVfdXYgPSBvYmplY3RVVjtcbiAgaWYgKHVfc2hhcGUgPCAzLjUpIHtcbiAgICBzaGFwZV91diA9IHBhdHRlcm5VVjtcbiAgfVxuXG4gIGZsb2F0IHNoYXBlID0gMC47XG4gIGlmICh1X3NoYXBlIDwgMS41KSB7XG4gICAgLy8gU2ltcGxleCBub2lzZVxuICAgIHNoYXBlX3V2ICo9IC4wMDE7XG5cbiAgICBzaGFwZSA9IDAuNSArIDAuNSAqIGdldFNpbXBsZXhOb2lzZShzaGFwZV91diwgdCk7XG4gICAgc2hhcGUgPSBzbW9vdGhzdGVwKDAuMywgMC45LCBzaGFwZSk7XG5cbiAgfSBlbHNlIGlmICh1X3NoYXBlIDwgMi41KSB7XG4gICAgLy8gV2FycFxuICAgIHNoYXBlX3V2ICo9IC4wMDM7XG5cbiAgICBmb3IgKGZsb2F0IGkgPSAxLjA7IGkgPCA2LjA7IGkrKykge1xuICAgICAgc2hhcGVfdXYueCArPSAwLjYgLyBpICogY29zKGkgKiAyLjUgKiBzaGFwZV91di55ICsgdCk7XG4gICAgICBzaGFwZV91di55ICs9IDAuNiAvIGkgKiBjb3MoaSAqIDEuNSAqIHNoYXBlX3V2LnggKyB0KTtcbiAgICB9XG5cbiAgICBzaGFwZSA9IC4xNSAvIGFicyhzaW4odCAtIHNoYXBlX3V2LnkgLSBzaGFwZV91di54KSk7XG4gICAgc2hhcGUgPSBzbW9vdGhzdGVwKDAuMDIsIDEuLCBzaGFwZSk7XG5cbiAgfSBlbHNlIGlmICh1X3NoYXBlIDwgMy41KSB7XG4gICAgLy8gRG90c1xuICAgIHNoYXBlX3V2ICo9IC4wNTtcblxuICAgIGZsb2F0IHN0cmlwZUlkeCA9IGZsb29yKDIuICogc2hhcGVfdXYueCAvIFRXT19QSSk7XG4gICAgZmxvYXQgcmFuZCA9IGhhc2gxMShzdHJpcGVJZHggKiAxMC4pO1xuICAgIHJhbmQgPSBzaWduKHJhbmQgLSAuNSkgKiBwb3coLjEgKyBhYnMocmFuZCksIC40KTtcbiAgICBzaGFwZSA9IHNpbihzaGFwZV91di54KSAqIGNvcyhzaGFwZV91di55IC0gNS4gKiByYW5kICogdCk7XG4gICAgc2hhcGUgPSBwb3coYWJzKHNoYXBlKSwgNi4pO1xuXG4gIH0gZWxzZSBpZiAodV9zaGFwZSA8IDQuNSkge1xuICAgIC8vIFNpbmUgd2F2ZVxuICAgIHNoYXBlX3V2ICo9IDQuO1xuXG4gICAgZmxvYXQgd2F2ZSA9IGNvcyguNSAqIHNoYXBlX3V2LnggLSAyLiAqIHQpICogc2luKDEuNSAqIHNoYXBlX3V2LnggKyB0KSAqICguNzUgKyAuMjUgKiBjb3MoMy4gKiB0KSk7XG4gICAgc2hhcGUgPSAxLiAtIHNtb290aHN0ZXAoLTEuLCAxLiwgc2hhcGVfdXYueSArIHdhdmUpO1xuXG4gIH0gZWxzZSBpZiAodV9zaGFwZSA8IDUuNSkge1xuICAgIC8vIFJpcHBsZVxuXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aChzaGFwZV91dik7XG4gICAgZmxvYXQgd2F2ZXMgPSBzaW4ocG93KGRpc3QsIDEuNykgKiA3LiAtIDMuICogdCkgKiAuNSArIC41O1xuICAgIHNoYXBlID0gd2F2ZXM7XG5cbiAgfSBlbHNlIGlmICh1X3NoYXBlIDwgNi41KSB7XG4gICAgLy8gU3dpcmxcblxuICAgIGZsb2F0IGwgPSBsZW5ndGgoc2hhcGVfdXYpO1xuICAgIGZsb2F0IGFuZ2xlID0gNi4gKiBhdGFuKHNoYXBlX3V2LnksIHNoYXBlX3V2LngpICsgNC4gKiB0O1xuICAgIGZsb2F0IHR3aXN0ID0gMS4yO1xuICAgIGZsb2F0IG9mZnNldCA9IHBvdyhsLCAtdHdpc3QpICsgYW5nbGUgLyBUV09fUEk7XG4gICAgZmxvYXQgbWlkID0gc21vb3Roc3RlcCgwLiwgMS4sIHBvdyhsLCB0d2lzdCkpO1xuICAgIHNoYXBlID0gbWl4KDAuLCBmcmFjdChvZmZzZXQpLCBtaWQpO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gU3BoZXJlXG4gICAgc2hhcGVfdXYgKj0gMi47XG5cbiAgICBmbG9hdCBkID0gMS4gLSBwb3cobGVuZ3RoKHNoYXBlX3V2KSwgMi4pO1xuICAgIHZlYzMgcG9zID0gdmVjMyhzaGFwZV91diwgc3FydChkKSk7XG4gICAgdmVjMyBsaWdodFBvcyA9IG5vcm1hbGl6ZSh2ZWMzKGNvcygxLjUgKiB0KSwgLjgsIHNpbigxLjI1ICogdCkpKTtcbiAgICBzaGFwZSA9IC41ICsgLjUgKiBkb3QobGlnaHRQb3MsIHBvcyk7XG4gICAgc2hhcGUgKj0gc3RlcCgwLiwgZCk7XG4gIH1cblxuXG4gIGludCB0eXBlID0gaW50KGZsb29yKHVfdHlwZSkpO1xuICBmbG9hdCBkaXRoZXJpbmcgPSAwLjA7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAxOiB7XG4gICAgICBkaXRoZXJpbmcgPSBzdGVwKGhhc2gyMShkaXRoZXJpbmdOb2lzZV91diksIHNoYXBlKTtcbiAgICB9IGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGRpdGhlcmluZyA9IGdldEJheWVyVmFsdWUoZGl0aGVyaW5nX3V2LCAyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGRpdGhlcmluZyA9IGdldEJheWVyVmFsdWUoZGl0aGVyaW5nX3V2LCA0KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBkaXRoZXJpbmcgPSBnZXRCYXllclZhbHVlKGRpdGhlcmluZ191diwgOCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGRpdGhlcmluZyAtPSAuNTtcbiAgZmxvYXQgcmVzID0gc3RlcCguNSwgc2hhcGUgKyBkaXRoZXJpbmcpO1xuXG4gIHZlYzMgZmdDb2xvciA9IHVfY29sb3JGcm9udC5yZ2IgKiB1X2NvbG9yRnJvbnQuYTtcbiAgZmxvYXQgZmdPcGFjaXR5ID0gdV9jb2xvckZyb250LmE7XG4gIHZlYzMgYmdDb2xvciA9IHVfY29sb3JCYWNrLnJnYiAqIHVfY29sb3JCYWNrLmE7XG4gIGZsb2F0IGJnT3BhY2l0eSA9IHVfY29sb3JCYWNrLmE7XG5cbiAgdmVjMyBjb2xvciA9IGZnQ29sb3IgKiByZXM7XG4gIGZsb2F0IG9wYWNpdHkgPSBmZ09wYWNpdHkgKiByZXM7XG5cbiAgY29sb3IgKz0gYmdDb2xvciAqICgxLiAtIG9wYWNpdHkpO1xuICBvcGFjaXR5ICs9IGJnT3BhY2l0eSAqICgxLiAtIG9wYWNpdHkpO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICAgIHZlYzIgaGVscGVyQm94ID0gb2JqZWN0SGVscGVyQm94O1xuICAgIHZlYzIgYm94U2l6ZSA9IG9iamVjdEJveFNpemU7XG4gICAgaWYgKHVfc2hhcGUgPCAzLjUpIHtcbiAgICAgIGhlbHBlckJveCA9IHBhdHRlcm5IZWxwZXJCb3g7XG4gICAgICBib3hTaXplID0gcGF0dGVybkJveFNpemU7XG4gICAgfVxuICAgICR7ZHJhd1NpemluZ0hlbHBlcnN9XG4gICNlbmRpZlxuXG4gIGZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xufVxuYDtcbmNvbnN0IERpdGhlcmluZ1NoYXBlcyA9IHtcbiAgc2ltcGxleDogMSxcbiAgd2FycDogMixcbiAgZG90czogMyxcbiAgd2F2ZTogNCxcbiAgcmlwcGxlOiA1LFxuICBzd2lybDogNixcbiAgc3BoZXJlOiA3XG59O1xuY29uc3QgRGl0aGVyaW5nVHlwZXMgPSB7XG4gIFwicmFuZG9tXCI6IDEsXG4gIFwiMngyXCI6IDIsXG4gIFwiNHg0XCI6IDMsXG4gIFwiOHg4XCI6IDRcbn07XG5leHBvcnQge1xuICBEaXRoZXJpbmdTaGFwZXMsXG4gIERpdGhlcmluZ1R5cGVzLFxuICBkaXRoZXJpbmdGcmFnbWVudFNoYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpdGhlcmluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shaders/dithering.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/vertex-shader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertexShaderSource: () => (/* binding */ vertexShaderSource)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_imageAspectRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\nout vec2 v_imageUV;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(u_resolution.x / boxRatio, u_resolution.y);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(u_resolution.x / boxRatio, u_resolution.y);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_objectHelperBox = uv;\n  v_objectHelperBox *= objectWorldScale;\n  v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_responsiveHelperBox = uv;\n  v_responsiveHelperBox *= responsiveBoxScale;\n  v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_patternHelperBox = uv;\n  v_patternHelperBox *= patternBoxScale;\n  v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  v_patternUV *= .01;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for images\n\n  vec2 imageBoxSize;\n  if (u_fit == 1.) { // contain\n    imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else if (u_fit == 2.) { // cover\n    imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else {\n    imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n  }\n  imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n  vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n  #ifdef ADD_HELPERS\n  vec2 imageHelperBox = uv;\n  imageHelperBox *= imageBoxScale;\n  imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n  #endif\n\n  v_imageUV = uv;\n  v_imageUV *= imageBoxScale;\n  v_imageUV += boxOrigin * (imageBoxScale - 1.);\n  v_imageUV += graphicOffset;\n  v_imageUV /= u_scale;\n  v_imageUV.x *= u_imageAspectRatio;\n  v_imageUV = graphicRotation * v_imageUV;\n  v_imageUV.x /= u_imageAspectRatio;\n\n  v_imageUV += .5;\n  v_imageUV.y = 1. - v_imageUV.y;\n\n  // ===================================================\n\n}`;\n\n//# sourceMappingURL=vertex-shader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBR0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcz8xMTlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgI3ZlcnNpb24gMzAwIGVzXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjNCBhX3Bvc2l0aW9uO1xuXG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSBmbG9hdCB1X3BpeGVsUmF0aW87XG51bmlmb3JtIGZsb2F0IHVfaW1hZ2VBc3BlY3RSYXRpbztcblxudW5pZm9ybSBmbG9hdCB1X29yaWdpblg7XG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWTtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZFdpZHRoO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkSGVpZ2h0O1xudW5pZm9ybSBmbG9hdCB1X2ZpdDtcblxudW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xudW5pZm9ybSBmbG9hdCB1X3JvdGF0aW9uO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFg7XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WTtcblxudW5pZm9ybSBmbG9hdCB1X3B4U2l6ZTtcblxub3V0IHZlYzIgdl9vYmplY3RVVjtcbm91dCB2ZWMyIHZfb2JqZWN0Qm94U2l6ZTtcbm91dCB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuXG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVVVjtcbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG5cbm91dCB2ZWMyIHZfcGF0dGVyblVWO1xub3V0IHZlYzIgdl9wYXR0ZXJuQm94U2l6ZTtcbm91dCB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtcblxub3V0IHZlYzIgdl9pbWFnZVVWO1xuXG4vLyAjZGVmaW5lIEFERF9IRUxQRVJTXG5cbnZlYzMgZ2V0Qm94U2l6ZShmbG9hdCBib3hSYXRpbywgdmVjMiBnaXZlbkJveFNpemUpIHtcbiAgdmVjMiBib3ggPSB2ZWMyKDAuKTtcbiAgLy8gZml0ID0gbm9uZVxuICBib3gueCA9IGJveFJhdGlvICogbWluKGdpdmVuQm94U2l6ZS54IC8gYm94UmF0aW8sIGdpdmVuQm94U2l6ZS55KTtcbiAgZmxvYXQgbm9GaXRCb3hXaWR0aCA9IGJveC54O1xuICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgIGJveC54ID0gYm94UmF0aW8gKiBtaW4odV9yZXNvbHV0aW9uLnggLyBib3hSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7IC8vIGZpdCA9IGNvdmVyXG4gICAgYm94LnggPSBib3hSYXRpbyAqIG1heCh1X3Jlc29sdXRpb24ueCAvIGJveFJhdGlvLCB1X3Jlc29sdXRpb24ueSk7XG4gIH1cbiAgYm94LnkgPSBib3gueCAvIGJveFJhdGlvO1xuICByZXR1cm4gdmVjMyhib3gsIG5vRml0Qm94V2lkdGgpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIGdsX1Bvc2l0aW9uID0gYV9wb3NpdGlvbjtcblxuICB2ZWMyIHV2ID0gZ2xfUG9zaXRpb24ueHkgKiAuNTtcbiAgdmVjMiBib3hPcmlnaW4gPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgZ2l2ZW5Cb3hTaXplID0gdmVjMih1X3dvcmxkV2lkdGgsIHVfd29ybGRIZWlnaHQpO1xuICBnaXZlbkJveFNpemUgPSBtYXgoZ2l2ZW5Cb3hTaXplLCB2ZWMyKDEuKSkgKiB1X3BpeGVsUmF0aW87XG4gIGZsb2F0IHIgPSB1X3JvdGF0aW9uICogMy4xNDE1OTI2NTM1ODk3OTMyMzg0NiAvIDE4MC47XG4gIG1hdDIgZ3JhcGhpY1JvdGF0aW9uID0gbWF0Mihjb3MociksIHNpbihyKSwgLXNpbihyKSwgY29zKHIpKTtcbiAgdmVjMiBncmFwaGljT2Zmc2V0ID0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGdyYXBoaWMgb2JqZWN0cyB3aXRoIGZpeGVkIHJhdGlvXG4gIC8vIChjdXJyZW50bHkgc3VwcG9ydHMgb25seSByYXRpbyA9IDEpXG5cbiAgZmxvYXQgZml4ZWRSYXRpbyA9IDEuO1xuICB2ZWMyIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcblxuICB2X29iamVjdEJveFNpemUgPSBnZXRCb3hTaXplKGZpeGVkUmF0aW8sIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUpLnh5O1xuICB2ZWMyIG9iamVjdFdvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyB2X29iamVjdEJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZfb2JqZWN0SGVscGVyQm94ID0gdXY7XG4gIHZfb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gIHZfb2JqZWN0SGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X29iamVjdFVWID0gdXY7XG4gIHZfb2JqZWN0VVYgKj0gb2JqZWN0V29ybGRTY2FsZTtcbiAgdl9vYmplY3RVViArPSBib3hPcmlnaW4gKiAob2JqZWN0V29ybGRTY2FsZSAtIDEuKTtcbiAgdl9vYmplY3RVViArPSBncmFwaGljT2Zmc2V0O1xuICB2X29iamVjdFVWIC89IHVfc2NhbGU7XG4gIHZfb2JqZWN0VVYgPSBncmFwaGljUm90YXRpb24gKiB2X29iamVjdFVWO1xuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgZ3JhcGhpYyBvYmplY3RzIHdpdGggZWl0aGVyIGdpdmVuQm94U2l6ZSByYXRpbyBvciBjYW52YXMgcmF0aW8uXG4gIC8vIEZ1bGwtc2NyZWVuIG1vZGUgYXZhaWxhYmxlIHdpdGggdV93b3JsZFdpZHRoID0gdV93b3JsZEhlaWdodCA9IDBcblxuICB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUgPSB2ZWMyKFxuICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcbiAgZmxvYXQgcmVzcG9uc2l2ZVJhdGlvID0gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnggLyB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUueTtcbiAgdl9yZXNwb25zaXZlQm94U2l6ZSA9IGdldEJveFNpemUocmVzcG9uc2l2ZVJhdGlvLCB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUpLnh5O1xuICB2ZWMyIHJlc3BvbnNpdmVCb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZfcmVzcG9uc2l2ZUhlbHBlckJveCA9IHV2O1xuICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggKj0gcmVzcG9uc2l2ZUJveFNjYWxlO1xuICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHJlc3BvbnNpdmVCb3hTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9yZXNwb25zaXZlVVYgPSB1djtcbiAgdl9yZXNwb25zaXZlVVYgKj0gcmVzcG9uc2l2ZUJveFNjYWxlO1xuICB2X3Jlc3BvbnNpdmVVViArPSBib3hPcmlnaW4gKiAocmVzcG9uc2l2ZUJveFNjYWxlIC0gMS4pO1xuICB2X3Jlc3BvbnNpdmVVViArPSBncmFwaGljT2Zmc2V0O1xuICB2X3Jlc3BvbnNpdmVVViAvPSB1X3NjYWxlO1xuICB2X3Jlc3BvbnNpdmVVVi54ICo9IHJlc3BvbnNpdmVSYXRpbztcbiAgdl9yZXNwb25zaXZlVVYgPSBncmFwaGljUm90YXRpb24gKiB2X3Jlc3BvbnNpdmVVVjtcbiAgdl9yZXNwb25zaXZlVVYueCAvPSByZXNwb25zaXZlUmF0aW87XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgcGF0dGVybnNcbiAgLy8gKHRyZWF0aW5nIGdyYXBoaWNzIGFzIGEgaW1hZ2UgdV93b3JsZFdpZHRoIHggdV93b3JsZEhlaWdodCBzaXplKVxuXG4gIGZsb2F0IHBhdHRlcm5Cb3hSYXRpbyA9IGdpdmVuQm94U2l6ZS54IC8gZ2l2ZW5Cb3hTaXplLnk7XG4gIHZlYzIgcGF0dGVybkJveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICApO1xuICBwYXR0ZXJuQm94UmF0aW8gPSBwYXR0ZXJuQm94R2l2ZW5TaXplLnggLyBwYXR0ZXJuQm94R2l2ZW5TaXplLnk7XG5cbiAgdmVjMyBib3hTaXplRGF0YSA9IGdldEJveFNpemUocGF0dGVybkJveFJhdGlvLCBwYXR0ZXJuQm94R2l2ZW5TaXplKTtcbiAgdl9wYXR0ZXJuQm94U2l6ZSA9IGJveFNpemVEYXRhLnh5O1xuICBmbG9hdCBwYXR0ZXJuQm94Tm9GaXRCb3hXaWR0aCA9IGJveFNpemVEYXRhLno7XG4gIHZlYzIgcGF0dGVybkJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9wYXR0ZXJuQm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgdl9wYXR0ZXJuSGVscGVyQm94ID0gdXY7XG4gIHZfcGF0dGVybkhlbHBlckJveCAqPSBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVybkhlbHBlckJveCArPSBib3hPcmlnaW4gKiAocGF0dGVybkJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X3BhdHRlcm5VViA9IHV2O1xuICB2X3BhdHRlcm5VViArPSBncmFwaGljT2Zmc2V0IC8gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5VViArPSBib3hPcmlnaW47XG4gIHZfcGF0dGVyblVWIC09IGJveE9yaWdpbiAvIHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuVVYgKj0gdV9yZXNvbHV0aW9uLnh5O1xuICB2X3BhdHRlcm5VViAvPSB1X3BpeGVsUmF0aW87XG4gIGlmICh1X2ZpdCA+IDAuKSB7XG4gICAgdl9wYXR0ZXJuVVYgKj0gKHBhdHRlcm5Cb3hOb0ZpdEJveFdpZHRoIC8gdl9wYXR0ZXJuQm94U2l6ZS54KTtcbiAgfVxuICB2X3BhdHRlcm5VViAvPSB1X3NjYWxlO1xuICB2X3BhdHRlcm5VViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfcGF0dGVyblVWO1xuICB2X3BhdHRlcm5VViArPSBib3hPcmlnaW4gLyBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVyblVWIC09IGJveE9yaWdpbjtcbiAgLy8geDEwMCBpcyBhIGRlZmF1bHQgbXVsdGlwbGllciBiZXR3ZWVuIHZlcnRleCBhbmQgZnJhZ21hbnQgc2hhZGVyc1xuICAvLyB3ZSB1c2UgaXQgdG8gYXZvaWQgVVYgcHJlc2lzaW9uIGlzc3Vlc1xuICB2X3BhdHRlcm5VViAqPSAuMDE7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgaW1hZ2VzXG5cbiAgdmVjMiBpbWFnZUJveFNpemU7XG4gIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBjb250YWluXG4gICAgaW1hZ2VCb3hTaXplLnggPSBtaW4odV9yZXNvbHV0aW9uLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIHVfcmVzb2x1dGlvbi55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBjb3ZlclxuICAgIGltYWdlQm94U2l6ZS54ID0gbWF4KHVfcmVzb2x1dGlvbi54IC8gdV9pbWFnZUFzcGVjdFJhdGlvLCB1X3Jlc29sdXRpb24ueSkgKiB1X2ltYWdlQXNwZWN0UmF0aW87XG4gIH0gZWxzZSB7XG4gICAgaW1hZ2VCb3hTaXplLnggPSBtaW4oMTAuMCwgMTAuMCAvIHVfaW1hZ2VBc3BlY3RSYXRpbyAqIHVfaW1hZ2VBc3BlY3RSYXRpbyk7XG4gIH1cbiAgaW1hZ2VCb3hTaXplLnkgPSBpbWFnZUJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgdmVjMiBpbWFnZUJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gaW1hZ2VCb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICB2ZWMyIGltYWdlSGVscGVyQm94ID0gdXY7XG4gIGltYWdlSGVscGVyQm94ICo9IGltYWdlQm94U2NhbGU7XG4gIGltYWdlSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X2ltYWdlVVYgPSB1djtcbiAgdl9pbWFnZVVWICo9IGltYWdlQm94U2NhbGU7XG4gIHZfaW1hZ2VVViArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgdl9pbWFnZVVWICs9IGdyYXBoaWNPZmZzZXQ7XG4gIHZfaW1hZ2VVViAvPSB1X3NjYWxlO1xuICB2X2ltYWdlVVYueCAqPSB1X2ltYWdlQXNwZWN0UmF0aW87XG4gIHZfaW1hZ2VVViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfaW1hZ2VVVjtcbiAgdl9pbWFnZVVWLnggLz0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuXG4gIHZfaW1hZ2VVViArPSAuNTtcbiAgdl9pbWFnZVVWLnkgPSAxLiAtIHZfaW1hZ2VVVi55O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG59YDtcbmV4cG9ydCB7XG4gIHZlcnRleFNoYWRlclNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnRleC1zaGFkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\n");

/***/ })

};
;